<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
<title>VR Nutrition — HOTFIX</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<style>
  html,body{margin:0;height:100%;background:#050910;overflow:hidden}
  a-scene,canvas.a-canvas{position:fixed;inset:0;z-index:0!important}
  .hud, #menuBar, #dbg {position:fixed;z-index:2147483647;color:#0ff;font-family:system-ui}
  .hud{left:50%;transform:translateX(-50%);top:8px;text-align:center}
  #menuBar{bottom:12px;left:50%;transform:translateX(-50%);text-align:center}
  .btn{display:inline-block;padding:10px 14px;margin:0 6px;border:1px solid #0ff;border-radius:12px;background:rgba(0,0,0,.35);color:#0ff;cursor:pointer}
  #dbg{left:8px;bottom:8px;white-space:pre;background:rgba(0,0,0,.5);padding:6px 8px;border-radius:8px;border:1px solid #0ff;font-size:12px}
  /* Allow interaction always */
  a-scene,canvas.a-canvas,.a-enter-vr{pointer-events:auto!important}
</style>
</head>
<body>
  <div class="hud">Score: <span id="score">0</span> | Combo: <span id="combo">x1</span> | Time: <span id="time">60</span>s</div>
  <div id="menuBar">
    <button id="btnStart" class="btn">▶ เริ่มเกม</button>
    <button id="btnPause" class="btn">⏸ พัก</button>
    <button id="btnRestart" class="btn">↻ เริ่มใหม่</button>
  </div>
  <div id="dbg">STATE: init</div>

  <a-scene id="scene" background="color:#050910" loading-screen="enabled:false" renderer="antialias:false;highRefreshRate:true">
    <a-assets timeout="1000">
      <img id="dot" src="assets/images/dot.png">
    </a-assets>
    <a-entity id="playerCam" position="0 1.6 0" camera look-controls
              raycaster="objects: .clickable; far: 12"
              cursor="rayOrigin: entity; fuse: true; fuseTimeout: 700">
      <a-entity position="0 0 -1" geometry="primitive:ring;radiusInner:0.005;radiusOuter:0.008"
                material="color:#0ff;shader:flat;opacity:0.9"></a-entity>
    </a-entity>
    <a-entity id="mouseRig" cursor="rayOrigin: mouse" raycaster="objects: .clickable; far: 12"></a-entity>
    <a-entity id="spawnerRoot" position="0 1.6 -2.2"></a-entity>
  </a-scene>

<script>
(function(){
  const $=s=>document.querySelector(s);
  const dbg=(m)=>{ const d=$("#dbg"); d.textContent = "STATE: " + m + "\n" + (window.__lastErr||""); };

  const APP={score:0,timeLeft:60,running:false,paused:false,combo:1,comboMax:1,difficulty:"Normal"};
  let spawnH=null,timerH=null, watchdogH=null, SPAWN_COUNT=0;
  const ACTIVE=new Set(), occ=new Set(), cool=new Map();
  const LANE_X=[-0.8,0,0.8], LANE_Y=[-0.05,0.12,0.29], LANE_Z=[-0.36,0,0.36];
  let last=null; const now=()=>performance.now(); const isAdj=(r,c)=> last?(Math.abs(last[0]-r)<=1 && Math.abs(last[1]-c)<=1):false;
  function lane(){
    const cand=[]; for(let r=0;r<3;r++)for(let c=0;c<3;c++){ const k=r+','+c,free=!occ.has(k)&&now()>(cool.get(k)||0)&&!isAdj(r,c); if(free) cand.push({r,c,k});}
    if(!cand.length) return null; const p=cand[Math.floor(Math.random()*cand.length)];
    occ.add(p.k); last=[p.r,p.c]; return {x:LANE_X[p.c],y:LANE_Y[p.r],z:LANE_Z[(p.r+p.c)%3],k:p.k};
  }
  function release(k){occ.delete(k);cool.set(k, now()+800);}
  function setHUD(){ $("#score").textContent=APP.score; $("#time").textContent=APP.timeLeft; $("#combo").textContent='x'+APP.combo; }

  function spawn(){
    try{
      const root=$("#spawnerRoot"); if(!root) return;
      if(ACTIVE.size>=(APP.difficulty==='Hard'?5:APP.difficulty==='Easy'?3:4)) return;
      const l=lane(); if(!l) return;
      const ent=document.createElement('a-entity');
      ent.setAttribute('geometry','primitive:plane;width:1;height:1');
      ent.setAttribute('material','shader:flat;color:#39d;opacity:0.98');
      ent.setAttribute('position',`${l.x} ${l.y} ${l.z}`);
      ent.setAttribute('scale','0.78 0.78 0.78');
      ent.setAttribute('class','clickable');
      ent.addEventListener('click',()=>{APP.score+=5*APP.combo;APP.combo=Math.min(5,APP.combo+1);setHUD(); remove();});
      function remove(){ if(ent.parentNode) ent.parentNode.removeChild(ent); ACTIVE.delete(ent); release(l.k); }
      root.appendChild(ent); ACTIVE.add(ent); SPAWN_COUNT++;
      setTimeout(()=>{ if(ent.parentNode){ APP.combo=1; setHUD(); remove(); }}, 3000);
    }catch(e){ window.__lastErr=String(e); dbg("spawn error"); }
  }
  function loop(){ if(!APP.running||APP.paused) return; spawn(); spawnH=setTimeout(loop, 740); }
  function tick(){ if(!APP.running||APP.paused) return; timerH=setTimeout(()=>{ APP.timeLeft--; setHUD(); if(APP.timeLeft<=0){ stop(); } else tick(); }, 1000); }

  function start(){
    APP.score=0; APP.combo=1; APP.comboMax=1; APP.timeLeft=60; setHUD();
    APP.running=true; APP.paused=false;
    dbg("start pressed");
    // watchdog: if no spawn/time after 1.2s, kick again
    clearTimeout(watchdogH);
    const timeSeen=APP.timeLeft, spSeen=SPAWN_COUNT;
    watchdogH=setTimeout(()=>{
      const stuck = (APP.timeLeft===timeSeen) || (SPAWN_COUNT===spSeen);
      if(stuck){ dbg("watchdog kick"); clearTimeout(spawnH); clearTimeout(timerH); setTimeout(()=>{ spawn(); loop(); tick(); }, 150); }
    }, 1200);
    setTimeout(()=>spawn(), 200);
    loop(); tick();
  }
  function pause(){ if(!APP.running) return; APP.paused=!APP.paused; if(APP.paused){ clearTimeout(spawnH); clearTimeout(timerH); dbg("paused"); } else { dbg("resumed"); loop(); tick(); } }
  function restart(){ stop(); start(); }
  function stop(){ APP.running=false; APP.paused=false; clearTimeout(spawnH); clearTimeout(timerH); clearTimeout(watchdogH); dbg("stopped"); }

  window.addEventListener('error', e=>{ window.__lastErr = (e.message||'') + " @ " + (e.filename||'') + ":" + (e.lineno||''); dbg("error"); });
  window.addEventListener('unhandledrejection', e=>{ window.__lastErr = String(e.reason||e); dbg("promise err"); });

  // Buttons
  document.getElementById('btnStart').addEventListener('click', start);
  document.getElementById('btnPause').addEventListener('click', pause);
  document.getElementById('btnRestart').addEventListener('click', restart);

  // Also auto-start when scene fully loaded
  const scene=document.getElementById('scene');
  if(scene){
    scene.addEventListener('loaded', ()=>{ dbg('scene loaded; ready'); });
  }
  // Auto-start after 2s as a final fallback
  setTimeout(()=>{ if(!APP.running){ dbg('auto-start fallback'); start(); } }, 2000);

})();</script>
</body>
</html>
