<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>HeroHealth ‚Äî Bath Hidden Dirt Quest (Top-down, PC/Mobile) vABC</title>
<style>
  :root{ --bg:#0b1020; --panel:#121a33; --txt:#e8ecff; --muted:#9aa6d6; --acc:#78c8ff; --bad:#ff5a78; --good:#6cff9f; }
  html,body{ height:100%; }
  body{ margin:0; background:var(--bg); color:var(--txt); font-family:system-ui,Segoe UI,Arial; }
  #wrap{ display:grid; grid-template-rows:auto 1fr auto; height:100dvh; }
  #hud{
    display:flex; gap:10px; align-items:center; padding:10px 12px;
    background:linear-gradient(180deg, rgba(18,26,51,.98), rgba(18,26,51,.70));
    border-bottom:1px solid rgba(255,255,255,.08);
    flex-wrap:wrap;
  }
  .pill{ padding:6px 10px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10); border-radius:999px; }
  .bar{ width:140px; height:10px; background:rgba(255,255,255,.08); border-radius:999px; overflow:hidden; display:inline-block; vertical-align:middle; }
  .fill{ height:100%; width:50%; background:rgba(120,200,255,.9); }
  #coach{ color:var(--muted); }
  #game{ position:relative; display:flex; justify-content:center; align-items:center; overflow:hidden; }
  canvas{ width:min(100vw, 860px); height:min(74vh, 580px); background:#071022; border:1px solid rgba(255,255,255,.12); border-radius:16px; touch-action:none; }
  #toolbar{
    display:flex; gap:8px; padding:10px 12px;
    background:linear-gradient(0deg, rgba(18,26,51,.98), rgba(18,26,51,.70));
    border-top:1px solid rgba(255,255,255,.08);
    align-items:center; justify-content:space-between;
  }
  .tools{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  button, select, input{
    background:rgba(255,255,255,.06); color:var(--txt);
    border:1px solid rgba(255,255,255,.14);
    border-radius:12px; padding:10px 12px; font-weight:800;
  }
  button.sel{ outline:2px solid rgba(120,200,255,.9); }
  #actionBtn{ padding:12px 16px; border-radius:16px; }
  #joy{ position:absolute; left:14px; bottom:14px; width:128px; height:128px; border-radius:64px;
        background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.10); display:none; }
  #nub{ position:absolute; left:48px; top:48px; width:32px; height:32px; border-radius:16px;
        background:rgba(120,200,255,.5); border:1px solid rgba(120,200,255,.9); }
  @media (pointer:coarse){ #joy{ display:block; } }

  /* Missions */
  #missions{
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
  }
  .mcard{
    min-width:220px;
    background:rgba(255,255,255,.05);
    border:1px solid rgba(255,255,255,.10);
    border-radius:14px;
    padding:8px 10px;
  }
  .mrow{ display:flex; justify-content:space-between; gap:8px; font-size:12px; color:var(--muted); }
  .mttl{ font-weight:900; color:var(--txt); }
  .mbar{ height:8px; background:rgba(255,255,255,.08); border-radius:999px; overflow:hidden; margin-top:6px; }
  .mfill{ height:100%; width:0%; background:rgba(108,255,159,.85); }

  /* Result overlay */
  #result{
    position:absolute; inset:0; display:none;
    background:rgba(7,16,34,.92);
    padding:18px; overflow:auto;
  }
  #result .card{
    max-width:860px; margin:0 auto; background:rgba(18,26,51,.88);
    border:1px solid rgba(255,255,255,.12); border-radius:18px; padding:14px;
  }
  #grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
  @media (max-width:860px){ #grid2{ grid-template-columns: 1fr; } }
  .h2{ font-size:18px; font-weight:900; margin:6px 0 10px; }
  .muted{ color:var(--muted); }
  .kpi{ display:flex; gap:10px; flex-wrap:wrap; }
  .kpi .pill{ background:rgba(255,255,255,.05); }
  #sil{ width:100%; height:auto; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.10); border-radius:14px; }
</style>
</head>
<body>
<div id="wrap">
  <div id="hud">
    <span class="pill">Phase: <b id="phaseLbl">PREP</b></span>
    <span class="pill">Time: <b id="timeLbl">80</b>s</span>
    <span class="pill">Heat <span class="bar"><span class="fill" id="heatFill"></span></span> <b id="heatLbl">0</b></span>
    <span class="pill">Bubble <span class="bar"><span class="fill" id="bubFill"></span></span> <b id="bubLbl">100</b></span>
    <span class="pill">Combo: <b id="comboLbl">x1.0</b></span>

    <div id="missions" style="width:100%;">
      <div class="mcard">
        <div class="mrow"><span class="mttl" id="m1t">Mission 1</span><span id="m1s">0/1</span></div>
        <div class="mbar"><div class="mfill" id="m1f"></div></div>
      </div>
      <div class="mcard">
        <div class="mrow"><span class="mttl" id="m2t">Mission 2</span><span id="m2s">0/1</span></div>
        <div class="mbar"><div class="mfill" id="m2f"></div></div>
      </div>
      <div class="mcard">
        <div class="mrow"><span class="mttl" id="m3t">Mission 3</span><span id="m3s">0/1</span></div>
        <div class="mbar"><div class="mfill" id="m3f"></div></div>
      </div>
    </div>

    <span class="pill" id="coach">Tip: ‡πÑ‡∏õ‡∏ó‡∏µ‡πà Shower ‡∏Å‡πà‡∏≠‡∏ô</span>
  </div>

  <div id="game">
    <canvas id="cv" width="860" height="580"></canvas>
    <div id="joy"><div id="nub"></div></div>

    <div id="result">
      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
          <div>
            <div class="h2">üèÅ End Summary ‚Äî Heatmap</div>
            <div class="muted" id="resSub">‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏ö‡∏ô‡πâ‡∏≥</div>
          </div>
          <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <button id="playAgain">‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
            <button id="closeRes">‡∏õ‡∏¥‡∏î</button>
          </div>
        </div>

        <div id="grid2" style="margin-top:10px;">
          <div>
            <canvas id="sil" width="560" height="440"></canvas>
            <div class="muted" style="margin-top:8px;" id="mistakes">Top mistakes:</div>
          </div>
          <div>
            <div class="h2">üìä Score Breakdown</div>
            <div class="kpi" id="kpi"></div>
            <div class="h2" style="margin-top:12px;">üß† Sequence Grade</div>
            <div class="pill" id="seqGrade">‚Äî</div>
            <div class="h2" style="margin-top:12px;">üß™ Notes</div>
            <div class="muted" id="notes">‚Äî</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="toolbar">
    <div class="tools" id="tools">
      <button data-tool="water">üíß Water</button>
      <button data-tool="soap">ü´ß Soap</button>
      <button data-tool="scrub">üßΩ Scrub</button>
      <button data-tool="rinse">üöø Rinse</button>
      <button data-tool="dry">üß∫ Dry</button>
      <button data-tool="scan">üî¶ UV Scan</button>
      <span class="pill">Diff:
        <select id="diffSel">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
        </select>
      </span>
      <span class="pill">Seed:
        <input id="seedInp" value="20260219" style="width:120px; font-weight:900;" />
      </span>
    </div>
    <button id="actionBtn">‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ</button>
  </div>
</div>

<script>
(() => {
  // ---------- DOM ----------
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const phaseLbl = document.getElementById('phaseLbl');
  const timeLbl  = document.getElementById('timeLbl');
  const heatLbl  = document.getElementById('heatLbl');
  const bubLbl   = document.getElementById('bubLbl');
  const comboLbl = document.getElementById('comboLbl');
  const heatFill = document.getElementById('heatFill');
  const bubFill  = document.getElementById('bubFill');
  const coach    = document.getElementById('coach');
  const toolsEl  = document.getElementById('tools');
  const actionBtn= document.getElementById('actionBtn');
  const diffSel  = document.getElementById('diffSel');
  const seedInp  = document.getElementById('seedInp');

  // Missions DOM
  const m1t=document.getElementById('m1t'), m1s=document.getElementById('m1s'), m1f=document.getElementById('m1f');
  const m2t=document.getElementById('m2t'), m2s=document.getElementById('m2s'), m2f=document.getElementById('m2f');
  const m3t=document.getElementById('m3t'), m3s=document.getElementById('m3s'), m3f=document.getElementById('m3f');

  const resultEl = document.getElementById('result');
  const silCv    = document.getElementById('sil');
  const silCtx   = silCv.getContext('2d');
  const kpiEl    = document.getElementById('kpi');
  const mistakesEl = document.getElementById('mistakes');
  const seqGradeEl = document.getElementById('seqGrade');
  const notesEl  = document.getElementById('notes');
  const resSubEl = document.getElementById('resSub');
  const playAgainBtn = document.getElementById('playAgain');
  const closeResBtn  = document.getElementById('closeRes');

  const W = cv.width, H = cv.height;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  // ---------- RNG (deterministic) ----------
  function xmur3(str){
    let h = 1779033703 ^ str.length;
    for(let i=0;i<str.length;i++){
      h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
      h = (h << 13) | (h >>> 19);
    }
    return function(){
      h = Math.imul(h ^ (h >>> 16), 2246822507);
      h = Math.imul(h ^ (h >>> 13), 3266489909);
      h ^= (h >>> 16);
      return h >>> 0;
    }
  }
  function sfc32(a,b,c,d){
    return function(){
      a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
      let t = (a + b) | 0;
      a = b ^ (b >>> 9);
      b = (c + (c << 3)) | 0;
      c = (c << 21) | (c >>> 11);
      d = (d + 1) | 0;
      t = (t + d) | 0;
      c = (c + t) | 0;
      return (t >>> 0) / 4294967296;
    }
  }
  function makeRng(seedStr){
    const seed = xmur3(seedStr);
    return sfc32(seed(), seed(), seed(), seed());
  }

  // ---------- Map (grid + collision) ----------
  const TILE = 28;
  const COLS = Math.floor(W / TILE);
  const ROWS = Math.floor(H / TILE);

  function makeMap(){
    const g = Array.from({length:ROWS}, ()=> Array(COLS).fill(0));
    const wall = (x,y)=>{ if(x>=0&&y>=0&&x<COLS&&y<ROWS) g[y][x]=1; };

    // outer walls
    for(let x=0;x<COLS;x++){ wall(x,0); wall(x,ROWS-1); }
    for(let y=0;y<ROWS;y++){ wall(0,y); wall(COLS-1,y); }

    // inner blocks
    for(let x=6;x<18;x++) wall(x,6);
    for(let y=10;y<18;y++) wall(6,y);
    for(let y=15;y<18;y++) for(let x=9;x<12;x++) wall(x,y);
    for(let y=3;y<5;y++) for(let x=20;x<24;x++) wall(x,y);

    // doorway
    g[ROWS-1][Math.floor(COLS/2)] = 0;

    return g;
  }
  let GRID = makeMap();

  function isBlocked(px,py,r){
    const minX = Math.floor((px-r)/TILE);
    const maxX = Math.floor((px+r)/TILE);
    const minY = Math.floor((py-r)/TILE);
    const maxY = Math.floor((py+r)/TILE);
    for(let ty=minY; ty<=maxY; ty++){
      for(let tx=minX; tx<=maxX; tx++){
        if(tx<0||ty<0||tx>=COLS||ty>=ROWS) return true;
        if(GRID[ty][tx]!==1) continue;
        const rx = tx*TILE, ry = ty*TILE;
        const cx = clamp(px, rx, rx+TILE);
        const cy = clamp(py, ry, ry+TILE);
        const dx = px-cx, dy = py-cy;
        if(dx*dx+dy*dy <= r*r) return true;
      }
    }
    return false;
  }

  // ---------- Stations ----------
  const ST = {
    shower: { id:'shower', x: 3*TILE, y: 3*TILE, r: 2.6*TILE, label:'üöø Shower' },
    soap:   { id:'soap',   x: 23*TILE, y: 4*TILE, r: 2.1*TILE, label:'ü´ß Soap Rack' },
    scan:   { id:'scan',   x: 23*TILE, y: 10*TILE, r: 2.1*TILE, label:'üî¶ UV Mirror' },
    towel:  { id:'towel',  x: 23*TILE, y: 16*TILE, r: 2.1*TILE, label:'üß∫ Towel' },
    basket: { id:'basket', x: 3*TILE,  y: 17*TILE, r: 2.2*TILE, label:'üëï Basket' },
  };
  function inZone(px,py, z){
    const dx=px-z.x, dy=py-z.y;
    return dx*dx+dy*dy <= z.r*z.r;
  }

  // ---------- A) Wet floor / slippery around shower ----------
  // Create a "wet region" bigger than shower. When wet, movement becomes slippery.
  const WET_FLOOR = { x: ST.shower.x, y: ST.shower.y, r: ST.shower.r*1.55 };

  // ---------- Player ----------
  const P = { x: 5*TILE, y: 16*TILE, r: 10, vx:0, vy:0 };

  // ---------- Difficulty ----------
  const DIFF = {
    easy:   { time: 90, bubble: 120, heatRise: 0.45, reveal: 0.80, holdMul: 0.75, bossChance: 0.45, scanLeft: 3 },
    normal: { time: 80, bubble: 100, heatRise: 0.60, reveal: 0.55, holdMul: 1.00, bossChance: 0.70, scanLeft: 2 },
    hard:   { time: 70, bubble: 90,  heatRise: 0.78, reveal: 0.35, holdMul: 1.18, bossChance: 0.92, scanLeft: 2 },
  };

  // ---------- Tools ----------
  let tool = 'water';
  let holding = false;
  let holdMs = 0;

  // ---------- Phases ----------
  const PH = { PREP:0, WET:1, SOAP:2, SCRUB:3, RINSE:4, DRY:5, DRESS:6, DONE:7 };
  let phase = PH.PREP;
  let prepMs = 2500;

  // ---------- Resources ----------
  let heat=0, bubble=100, tLeft=80;
  let combo=1.0;

  // ---------- Stats ----------
  const STATS = {
    cleanScore:0,
    residuePenalty:0,
    fungusRisk:0,
    seqOk:0,
    seqBad:0,
    wrongOrder:0,
    regrowCount:0,
    spreadCount:0,
    bossKilled:0,
    scansUsed:0,
    slips:0,
  };

  // ---------- Spots pool ----------
  const SPOT_POOL = [
    { id:'behindEar',  name:'‡∏´‡∏•‡∏±‡∏á‡∏´‡∏π',        ox:-10, oy:-18, hold:1200, weight:1.3, zone:'head' },
    { id:'neckBack',   name:'‡∏´‡∏•‡∏±‡∏á‡∏Ñ‡∏≠',        ox: 10, oy:-16, hold:1400, weight:1.4, zone:'head' },
    { id:'armpit',     name:'‡∏£‡∏±‡∏Å‡πÅ‡∏£‡πâ',        ox: 16, oy:  0, hold:1700, weight:1.6, zone:'arms' },
    { id:'elbowFold',  name:'‡∏Ç‡πâ‡∏≠‡∏û‡∏±‡∏ö‡πÅ‡∏Ç‡∏ô',     ox:-18, oy:  2, hold:1500, weight:1.5, zone:'arms' },
    { id:'belly',      name:'‡∏£‡∏≠‡∏ö‡∏™‡∏∞‡∏î‡∏∑‡∏≠',      ox:  0, oy:  6, hold:1350, weight:1.3, zone:'torso' },
    { id:'backKnee',   name:'‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏Ç‡πà‡∏≤',      ox: -8, oy: 18, hold:1500, weight:1.5, zone:'legs' },
    { id:'toes',       name:'‡∏ã‡∏≠‡∏Å‡∏ô‡∏¥‡πâ‡∏ß‡πÄ‡∏ó‡πâ‡∏≤',   ox: 10, oy: 22, hold:1800, weight:1.7, zone:'legs' },
  ];

  let rng = makeRng(seedInp.value.trim() || '20260219');
  let scanLeft = 2;
  let spots = [];
  let boss = null; // {type, spotId, hp, armor, pulseT, spreadT}

  // ---------- B) Missions (3 cards + progress + bonus) ----------
  let missions = [];
  function makeMissions(){
    // deterministic by seed + diff
    const d = DIFF[diffSel.value] || DIFF.normal;
    const r = rng;

    // pick 2 focus spots for mission 1
    const pickSpot = () => spots[Math.floor(r()*spots.length)];
    const s1 = pickSpot();
    let s2 = pickSpot();
    if(s2.id===s1.id) s2 = spots[(spots.indexOf(s1)+1)%spots.length];

    missions = [
      {
        id:'m1',
        title:`‡∏•‡πà‡∏≤‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö: ${s1.name} + ${s2.name}`,
        type:'cleanSpecific',
        targets:[s1.id, s2.id],
        done:0, need:2,
        bonus:20,
        hint:'‡∏ó‡∏≥‡∏•‡∏≥‡∏î‡∏±‡∏ö Wet‚ÜíSoap‚ÜíScrub‚ÜíRinse ‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö',
      },
      {
        id:'m2',
        title:`‡∏Ñ‡∏∏‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡πâ‡∏≠‡∏ô: Heat ‚â§ ${diffSel.value==='hard'?60:65}`,
        type:'keepHeat',
        threshold: diffSel.value==='hard'?60:65,
        done:0, need:1,
        bonus:15,
        hint:'‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô Shower ‡∏à‡∏∞‡πÄ‡∏¢‡πá‡∏ô‡∏•‡∏á + ‡∏ó‡∏≥‡∏Ñ‡∏≠‡∏°‡πÇ‡∏ö‡∏ñ‡∏π‡∏Å‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏•‡∏î Heat',
      },
      {
        id:'m3',
        title:`‡∏•‡πâ‡∏≤‡∏á‡∏ü‡∏≠‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏ô‡∏µ‡∏¢‡∏ô: Residue ‚â§ ${diffSel.value==='hard'?6:8}`,
        type:'limitResidue',
        limit: diffSel.value==='hard'?6:8,
        done:0, need:1,
        bonus:15,
        hint:'‡∏≠‡∏¢‡πà‡∏≤‡∏Ç‡πâ‡∏≤‡∏° Rinse ‡πÅ‡∏•‡∏∞‡∏≠‡∏¢‡πà‡∏≤‡∏ñ‡∏π‡πÄ‡∏£‡πá‡∏ß‡πÑ‡∏õ (Fake clean)',
      },
    ];

    renderMissions();
  }
  function renderMissions(){
    const m1=missions[0], m2=missions[1], m3=missions[2];
    if(!m1||!m2||!m3) return;
    m1t.textContent=m1.title; m2t.textContent=m2.title; m3t.textContent=m3.title;
    updateMissionUI();
  }
  function updateMissionUI(){
    const ms = missions;
    if(!ms.length) return;
    const set = (m, sEl, fEl) => {
      sEl.textContent = `${m.done}/${m.need}`;
      fEl.style.width = `${Math.round((m.done/m.need)*100)}%`;
    };
    set(ms[0], m1s, m1f);
    set(ms[1], m2s, m2f);
    set(ms[2], m3s, m3f);
  }
  function missionAddDone(id, inc=1){
    const m = missions.find(x=>x.id===id);
    if(!m) return;
    m.done = clamp(m.done + inc, 0, m.need);
    updateMissionUI();
  }
  function missionFinalize(){
    // Called on endGame to confirm pass/fail style missions
    const m2 = missions.find(m=>m.id==='m2');
    const m3 = missions.find(m=>m.id==='m3');
    if(m2 && heat <= m2.threshold) m2.done = m2.need;
    if(m3 && STATS.residuePenalty <= m3.limit) m3.done = m3.need;
    updateMissionUI();
  }
  function missionBonusTotal(){
    let b=0;
    for(const m of missions){ if(m.done>=m.need) b += m.bonus; }
    return b;
  }

  // ---------- C) AI Coach micro-tip (rate-limit + explainable + deterministic) ----------
  const COACH = {
    lastAt: -9999,
    cooldownMs: 1400,     // rate-limit
    lastMsg: '',
  };
  function coachSay(msg){
    // rate limit: only if enough time passed OR different important message
    const now = performance.now();
    if(now - COACH.lastAt < COACH.cooldownMs && msg === COACH.lastMsg) return;
    COACH.lastAt = now;
    COACH.lastMsg = msg;
    coach.textContent = 'Tip: ' + msg;
  }
  function coachCheck(){
    // deterministic-style logic based on current state; no random choices except stable conditions
    if(phase===PH.WET){
      if(!inZone(P.x,P.y, ST.shower)) coachSay('Wet ‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡πÉ‡∏ô Shower ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏µ‡∏¢‡∏Å‡∏ó‡∏±‡πà‡∏ß ‡∏ü‡∏≠‡∏Å‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏ï‡∏¥‡∏î');
      else if(tool!=='water') coachSay('‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡∏π‡πà Shower ‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏ä‡πâ Water ‡∏à‡∏∞‡∏Ñ‡∏∏‡πâ‡∏°‡∏™‡∏∏‡∏î (‡∏•‡∏î Heat ‡∏î‡πâ‡∏ß‡∏¢)');
    }
    if(phase===PH.SOAP){
      if(!inZone(P.x,P.y, ST.soap)) coachSay('‡πÑ‡∏õ Soap Rack ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ü‡∏≠‡∏Å‡πÉ‡∏Å‡∏•‡πâ‡∏à‡∏∏‡∏î‡∏™‡∏ö‡∏π‡πà ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡∏•‡∏∑‡∏≠‡∏á Bubble ‡∏ô‡πâ‡∏≠‡∏¢');
      if(tool!=='soap') coachSay('Phase Soap ‡∏Ñ‡∏ß‡∏£‡πÉ‡∏ä‡πâ Soap ‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡∏π ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ñ‡∏π‡πÄ‡∏£‡πá‡∏ß‡πÑ‡∏õ‡∏à‡∏∞ ‚Äú‡∏õ‡∏•‡∏≠‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‚Äù');
    }
    if(phase===PH.SCRUB){
      const soaped = spots.filter(s=>s.state==='soaped');
      if(!soaped.length) coachSay('‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà Soap ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ï‡πâ‡∏≠‡∏á‡∏ü‡∏≠‡∏Å‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡∏∂‡∏á‡∏ñ‡∏π‡πÑ‡∏î‡πâ‡∏ú‡∏•');
      if(tool!=='scrub') coachSay('Phase Scrub ‡πÉ‡∏ä‡πâ Scrub ‡πÅ‡∏•‡∏∞ ‚Äú‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‚Äù ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤');
      if(bubble<18) coachSay('Bubble ‡πÉ‡∏Å‡∏•‡πâ‡∏´‡∏°‡∏î ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ü‡∏≠‡∏Å/‡∏ñ‡∏π‡∏à‡∏∞‡∏ä‡πâ‡∏≤‡∏•‡∏á ‡∏•‡∏≠‡∏á‡πÑ‡∏õ Shower ‡∏•‡∏î Heat ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡∏ï‡πà‡∏≠');
    }
    if(phase===PH.RINSE){
      if(!inZone(P.x,P.y, ST.shower)) coachSay('Rinse ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏•‡∏±‡∏ö Shower ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏•‡πâ‡∏≤‡∏á‡∏ü‡∏≠‡∏á Residue ‡∏à‡∏∞‡∏ï‡∏¥‡∏î‡∏•‡∏ö');
    }
    if(phase===PH.DRY){
      if(!inZone(P.x,P.y, ST.towel)) coachSay('‡πÑ‡∏õ Towel ‡πÄ‡∏û‡∏∑‡πà‡∏≠ Dry ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ä‡∏∑‡πâ‡∏ô = fungus risk ‡πÄ‡∏û‡∏¥‡πà‡∏°');
    }
  }

  // ---------- Fair spawn ----------
  function spawnSpots(){
    const pool = [...SPOT_POOL];
    const pick = (fn)=>{
      const candidates = pool.filter(fn);
      if(!candidates.length) return null;
      const idx = Math.floor(rng()*candidates.length);
      const s = candidates[idx];
      pool.splice(pool.indexOf(s),1);
      return s;
    };
    const out = [];
    const sLeg = pick(s=>s.zone==='legs'); if(sLeg) out.push(sLeg);
    const sHead = pick(s=>s.zone==='head'); if(sHead) out.push(sHead);
    const sArms = pick(s=>s.zone==='arms'); if(sArms) out.push(sArms);
    while(out.length<4 && pool.length){
      const idx = Math.floor(rng()*pool.length);
      out.push(pool.splice(idx,1)[0]);
    }
    spots = out.map(s=>({
      ...s,
      state:'hidden',
      prog:0,
      shinyNotClean:false,
      wetUnlocked:false,
      lastStep:'none',
      mistakes:0,
      cleaned:false
    }));
  }

  // ---------- Sequence rules ----------
  function seqStepOk(prev, next){
    const order = ['none','wet','soap','scrub','rinse','dry','dress'];
    return order.indexOf(next) === order.indexOf(prev)+1;
  }
  function applySeq(spot, step){
    if(seqStepOk(spot.lastStep, step)){
      spot.lastStep = step;
      STATS.seqOk++;
      combo = clamp(combo + 0.03, 1.0, 2.0);
      return true;
    } else {
      STATS.seqBad++;
      STATS.wrongOrder++;
      combo = clamp(combo - 0.06, 1.0, 2.0);

      // punish fair
      const roll = rng();
      if(roll < 0.55){
        STATS.regrowCount++;
        spot.mistakes++;
        if(spot.state==='soaped' || spot.state==='scrubbing') spot.state='revealed';
        if(spot.state==='cleanCandidate') spot.state='soaped';
        spot.prog=0;
        heat = clamp(heat + 3, 0, 100);
        coachSay(`‡∏ú‡∏¥‡∏î‡∏•‡∏≥‡∏î‡∏±‡∏ö ‚Üí ‡∏Ñ‡∏£‡∏≤‡∏ö‡∏ü‡∏∑‡πâ‡∏ô‡∏ï‡∏±‡∏ß (${spot.name}) ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏Ç‡πâ‡∏≤‡∏°‡∏Ç‡∏±‡πâ‡∏ô`);
      } else {
        STATS.spreadCount++;
        heat = clamp(heat + 4, 0, 100);
        const hidden = spots.find(s=>s.state==='hidden');
        if(hidden){ hidden.state='revealed'; hidden.wetUnlocked=true; }
        STATS.residuePenalty += 2;
        coachSay('‡∏ú‡∏¥‡∏î‡∏•‡∏≥‡∏î‡∏±‡∏ö ‚Üí ‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢ ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÑ‡∏õ‡∏Ç‡∏±‡πâ‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ‡∏ï‡∏≠‡∏ô‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏™‡∏∞‡∏≠‡∏≤‡∏î');
      }
      return false;
    }
  }

  // ---------- Boss ----------
  function maybeSpawnBoss(){
    if(boss) return;
    const d = DIFF[diffSel.value] || DIFF.normal;
    const trigger = (heat > 72) || (STATS.wrongOrder >= 2) || (tLeft < d.time*0.55 && !allCleanCandidate());
    if(!trigger) return;
    if(rng() > d.bossChance) return;

    let s = spots.find(x=>x.state==='revealed' || x.state==='soaped') || spots[0];
    if(s.state==='hidden'){ s.state='revealed'; s.wetUnlocked=true; }
    const type = (rng()<0.5) ? 'stink' : 'oil';

    boss = {
      type,
      spotId: s.id,
      hp: type==='stink' ? 100 : 120,
      armor: type==='oil' ? 3 : 0,
      pulseT: 0,
      spreadT: 0,
    };
    coachSay(type==='stink'
      ? '‚ö†Ô∏è Stink Monster: ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏•‡πâ‡∏≤‡∏á‡∏ñ‡∏π‡∏Å‡∏•‡∏≥‡∏î‡∏±‡∏ö ‡∏Å‡∏•‡∏¥‡πà‡∏ô‡∏à‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏° Heat ‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏≤‡∏ö‡πÇ‡∏ï‡πÑ‡∏ß'
      : '‚ö†Ô∏è Oil Boss: ‡∏ï‡πâ‡∏≠‡∏á Wet ‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡∏∂‡∏á‡∏à‡∏∞‡∏•‡∏≠‡∏Å‡∏ä‡∏±‡πâ‡∏ô‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô ‡πÑ‡∏°‡πà‡∏á‡∏±‡πâ‡∏ô‡∏ñ‡∏π‡πÄ‡∏ó‡πà‡∏≤‡πÑ‡∏´‡∏£‡πà‡∏Å‡πá‡πÑ‡∏°‡πà‡∏•‡∏á');
  }
  function updateBoss(dt){
    if(!boss) return;
    boss.pulseT += dt;
    boss.spreadT += dt;
    if(boss.pulseT > 1500){
      boss.pulseT = 0;
      heat = clamp(heat + (boss.type==='stink'?4:3), 0, 100);
      STATS.residuePenalty += (boss.type==='stink'?2:1);
    }
    if(boss.spreadT > (boss.type==='stink'?2400:2800)){
      boss.spreadT = 0;
      const hidden = spots.find(s=>s.state==='hidden');
      if(hidden){
        hidden.state='revealed'; hidden.wetUnlocked=true;
        STATS.spreadCount++;
      } else {
        const c = spots.find(s=>s.state==='cleanCandidate' || s.state==='rinsed');
        if(c){
          c.state='soaped'; c.prog=0; c.shinyNotClean=true;
          STATS.regrowCount++;
        }
      }
    }
  }
  function damageBoss(amount){
    if(!boss) return;
    boss.hp -= amount;
    if(boss.hp<=0){
      STATS.bossKilled++;
      bubble = clamp(bubble + 18, 0, 140);
      heat = clamp(heat - 14, 0, 100);
      boss = null;
      coachSay('‚úÖ Boss ‡∏ñ‡∏π‡∏Å‡∏ä‡∏≥‡∏£‡∏∞! ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ó‡∏≥‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Ñ‡∏£‡∏ö ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö‡πÑ‡∏°‡πà‡∏™‡∏∞‡∏™‡∏°‡∏Ñ‡∏£‡∏≤‡∏ö');
    }
  }

  // ---------- Helpers ----------
  function inCircle(px,py,cx,cy,r){
    const dx=px-cx, dy=py-cy;
    return dx*dx+dy*dy <= r*r;
  }
  function tipForTool(){
    if(phase===PH.DONE) return;
    if(tool==='water') coachSay('Water ‡πÉ‡∏ô Shower: ‡∏•‡∏î Heat ‡πÅ‡∏•‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏ü‡∏≠‡∏Å‡∏ï‡∏¥‡∏î‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô');
    else if(tool==='soap') coachSay('Soap ‡∏ó‡∏µ‡πà Soap Rack: ‡∏Ñ‡∏∏‡πâ‡∏° Bubble ‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏Å‡∏≤‡∏£‡∏ñ‡∏π');
    else if(tool==='scrub') coachSay('Scrub: ‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠ ‚Äú‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏à‡∏£‡∏¥‡∏á‚Äù ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÅ‡∏Ñ‡πà‡πÄ‡∏á‡∏≤');
    else if(tool==='rinse') coachSay('Rinse ‡πÉ‡∏ô Shower: ‡∏Å‡∏±‡∏ô residue ‡∏ï‡∏¥‡∏î‡∏•‡∏ö');
    else if(tool==='dry') coachSay('Dry ‡∏ó‡∏µ‡πà Towel: ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏∑‡πâ‡∏ô ‡∏•‡∏î fungus risk');
    else if(tool==='scan') coachSay('UV Scan ‡∏ó‡∏µ‡πà Mirror: ‡πÄ‡∏´‡πá‡∏ô‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö (‡∏°‡∏µ‡∏à‡∏≥‡∏Å‡∏±‡∏î)');
  }
  function setTool(t){
    tool = t;
    [...toolsEl.querySelectorAll('button[data-tool]')].forEach(x=>x.classList.toggle('sel', x.dataset.tool===tool));
    tipForTool();
  }
  function setPhase(p){
    phase = p;
    phaseLbl.textContent = Object.keys(PH).find(k=>PH[k]===phase);
    if(phase===PH.WET) coachSay('Phase Wet: ‡πÑ‡∏õ Shower ‡πÅ‡∏•‡πâ‡∏ß Water ‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö (‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö)');
    if(phase===PH.SOAP) coachSay('Phase Soap: ‡πÑ‡∏õ Soap Rack ‡πÅ‡∏•‡πâ‡∏ß‡∏ü‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö');
    if(phase===PH.SCRUB) coachSay('Phase Scrub: ‡∏ñ‡∏π‡∏Ñ‡πâ‡∏≤‡∏á‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ (‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö‡∏ô‡∏≤‡∏ô‡∏Å‡∏ß‡πà‡∏≤)');
    if(phase===PH.RINSE) coachSay('Phase Rinse: ‡∏Å‡∏•‡∏±‡∏ö Shower ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡πâ‡∏≤‡∏á‡∏ü‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î');
    if(phase===PH.DRY) coachSay('Phase Dry: ‡πÄ‡∏ä‡πá‡∏î‡πÉ‡∏´‡πâ‡πÅ‡∏´‡πâ‡∏á ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡∏£‡∏≤');
    if(phase===PH.DRESS) coachSay('Phase Dress: ‡πÉ‡∏™‡πà‡πÄ‡∏™‡∏∑‡πâ‡∏≠‡∏ú‡πâ‡∏≤‡∏™‡∏∞‡∏≠‡∏≤‡∏î ‡∏õ‡∏¥‡∏î‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à');
  }
  function allCleanCandidate(){
    return spots.every(s=> s.state==='cleanCandidate' || s.state==='rinsed' || s.state==='dried' || s.state==='done');
  }
  function allRinsed(){
    return spots.every(s=> s.state==='rinsed' || s.state==='dried' || s.state==='done');
  }

  // ---------- Input ----------
  const keys = {};
  addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
  addEventListener('keyup',   e => { keys[e.key.toLowerCase()] = false; });

  function setHolding(v){ holding=v; if(!v) holdMs=0; }
  actionBtn.addEventListener('pointerdown', e=>{ actionBtn.setPointerCapture(e.pointerId); setHolding(true); });
  actionBtn.addEventListener('pointerup',   ()=> setHolding(false));
  actionBtn.addEventListener('pointercancel',()=> setHolding(false));
  cv.addEventListener('pointerdown', e=>{ cv.setPointerCapture(e.pointerId); setHolding(true); });
  cv.addEventListener('pointerup',   ()=> setHolding(false));
  cv.addEventListener('pointercancel',()=> setHolding(false));

  // Joystick
  const joy = document.getElementById('joy');
  const nub = document.getElementById('nub');
  let joyOn=false, joyId=null, joyCx=0, joyCy=0, joyDx=0, joyDy=0;
  joy.addEventListener('pointerdown', e=>{
    joy.setPointerCapture(e.pointerId);
    joyOn=true; joyId=e.pointerId;
    const r = joy.getBoundingClientRect();
    joyCx = r.left + r.width/2;
    joyCy = r.top + r.height/2;
    updateJoy(e.clientX, e.clientY);
  });
  joy.addEventListener('pointermove', e=>{
    if(!joyOn || e.pointerId!==joyId) return;
    updateJoy(e.clientX, e.clientY);
  });
  joy.addEventListener('pointerup', e=>{
    if(e.pointerId!==joyId) return;
    joyOn=false; joyId=null; joyDx=joyDy=0;
    nub.style.left='48px'; nub.style.top='48px';
  });
  function updateJoy(x,y){
    const dx=x-joyCx, dy=y-joyCy;
    const m=Math.sqrt(dx*dx+dy*dy);
    const max=44;
    const nx=(m>max? dx/m*max : dx);
    const ny=(m>max? dy/m*max : dy);
    joyDx=nx/max; joyDy=ny/max;
    nub.style.left=(48+nx)+'px';
    nub.style.top =(48+ny)+'px';
  }

  // ---------- Restart ----------
  diffSel.addEventListener('change', ()=> restart());
  seedInp.addEventListener('change', ()=> restart());
  playAgainBtn.addEventListener('click', ()=> restart());
  closeResBtn.addEventListener('click', ()=> { resultEl.style.display='none'; });

  function restart(){
    GRID = makeMap();
    rng = makeRng(seedInp.value.trim() || '20260219');
    const d = DIFF[diffSel.value] || DIFF.normal;

    heat=0; bubble=d.bubble; tLeft=d.time; combo=1.0;
    prepMs=2200; phase=PH.PREP;
    boss=null;

    for(const k of Object.keys(STATS)) STATS[k]=0;
    scanLeft = d.scanLeft;

    spawnSpots();
    makeMissions(); // B

    P.x = 5*TILE; P.y = 16*TILE;
    P.vx=0; P.vy=0;

    resultEl.style.display='none';
    setPhase(PH.PREP);
    setTool('water');
    coachSay('‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏•‡∏¢! ‡πÑ‡∏õ Shower ‡∏Å‡πà‡∏≠‡∏ô');
  }

  // ---------- Loop ----------
  let last = performance.now();
  restart();
  requestAnimationFrame(frame);

  function frame(now){
    const dt = now-last; last=now;
    update(dt);
    render();
    requestAnimationFrame(frame);
  }

  function update(dt){
    if(phase===PH.DONE) return;

    const d = DIFF[diffSel.value] || DIFF.normal;

    // prep timer
    if(phase===PH.PREP){
      prepMs -= dt;
      if(prepMs<=0) setPhase(PH.WET);
    } else {
      // countdown
      tLeft -= dt/1000; if(tLeft<0) tLeft=0;
      // heat rises baseline
      heat += (dt/1000) * d.heatRise;
      if(!holding) heat += (dt/1000)*0.10;
    }

    // A) slippery wet floor around shower
    const onWetFloor = inCircle(P.x,P.y, WET_FLOOR.x, WET_FLOOR.y, WET_FLOOR.r);

    // movement input
    let mx=0,my=0;
    if(keys['arrowleft']||keys['a']) mx-=1;
    if(keys['arrowright']||keys['d']) mx+=1;
    if(keys['arrowup']||keys['w']) my-=1;
    if(keys['arrowdown']||keys['s']) my+=1;
    mx += joyDx; my += joyDy;
    const m = Math.hypot(mx,my);
    if(m>1e-3){ mx/=Math.max(1,m); my/=Math.max(1,m); }

    // velocity with friction (slippery => lower friction)
    const accel = 900;
    const fric  = onWetFloor ? 5.5 : 10.5;  // lower friction => slide
    P.vx += mx * accel * (dt/1000);
    P.vy += my * accel * (dt/1000);
    P.vx *= Math.exp(-fric*(dt/1000));
    P.vy *= Math.exp(-fric*(dt/1000));

    // cap speed (slippery slightly higher)
    const vmax = onWetFloor ? 230 : 200;
    const sp = Math.hypot(P.vx,P.vy);
    if(sp>vmax){
      P.vx = P.vx/sp*vmax;
      P.vy = P.vy/sp*vmax;
    }

    // move with collision (axis separate)
    let nx = P.x + P.vx*(dt/1000);
    let ny = P.y;
    if(!isBlocked(nx,ny,P.r)) P.x = nx;
    else { P.vx *= -0.22; heat = clamp(heat + 0.35,0,100); if(onWetFloor){ STATS.slips++; } }
    nx = P.x;
    ny = P.y + P.vy*(dt/1000);
    if(!isBlocked(nx,ny,P.r)) P.y = ny;
    else { P.vy *= -0.22; heat = clamp(heat + 0.35,0,100); if(onWetFloor){ STATS.slips++; } }

    // clamp resources
    heat = clamp(heat, 0, 100);
    bubble = clamp(bubble, 0, 140);

    // boss update
    updateBoss(dt);

    // reveal trickle
    if(phase>=PH.WET){
      for(const s of spots){
        if(s.state==='hidden'){
          const chance = d.reveal * (inZone(P.x,P.y, ST.shower) ? 1.0 : 0.35);
          if(rng() < chance*0.005){ s.state='revealed'; s.wetUnlocked=true; }
        }
      }
    }

    // Holding actions
    if(holding){
      holdMs += dt;

      const atShower = inZone(P.x,P.y,ST.shower);
      const atSoap   = inZone(P.x,P.y,ST.soap);
      const atScan   = inZone(P.x,P.y,ST.scan);
      const atTowel  = inZone(P.x,P.y,ST.towel);
      const atBasket = inZone(P.x,P.y,ST.basket);

      // Scan (station-based)
      if(tool==='scan'){
        if(atScan && holdMs>220 && scanLeft>0){
          scanLeft--;
          STATS.scansUsed++;
          for(const s of spots){ if(s.state==='hidden'){ s.state='revealed'; s.wetUnlocked=true; } }
          heat = clamp(heat + 4, 0, 100);
          coachSay(`UV Scan ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏ã‡πà‡∏≠‡∏ô‡∏≠‡∏¢‡∏π‡πà (‡πÄ‡∏´‡∏•‡∏∑‡∏≠ ${scanLeft})`);
          setHolding(false);
        } else if(!atScan && holdMs>300){
          coachSay('Scan ‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏ó‡∏µ‡πà UV Mirror ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏Ñ‡∏£‡∏≤‡∏ö');
          setHolding(false);
        }
      }

      // Phase WET
      if(phase===PH.WET){
        if(tool==='water' && atShower){
          // cooling (A): shower cools more
          heat = clamp(heat - dt/1000*0.55, 0, 100);
          for(const s of spots){
            if(s.state==='hidden' && rng()<0.012){ s.state='revealed'; s.wetUnlocked=true; }
            if(s.state==='revealed'){
              applySeq(s,'wet');
            }
          }
          const wetCount = spots.filter(s=>s.lastStep==='wet').length;
          if(wetCount>=3) setPhase(PH.SOAP);
        } else if(tool==='water' && !atShower && holdMs>260){
          coachSay('Wet ‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡πÉ‡∏ô Shower ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÄ‡∏õ‡∏µ‡∏¢‡∏Å‡πÑ‡∏°‡πà‡∏ó‡∏±‡πà‡∏ß ‡∏ü‡∏≠‡∏á‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏°‡πà‡πÄ‡∏ï‡πá‡∏°');
        }
      }

      // Phase SOAP
      if(phase===PH.SOAP){
        if(tool==='soap' && atSoap){
          for(const s of spots){
            if(s.state==='revealed'){
              applySeq(s,'soap');
              bubble -= dt/1000 * 10 * s.weight;
              s.prog = clamp(s.prog + dt/1000 * 0.70, 0, 1);
              if(s.prog>=1){
                s.state='soaped'; s.prog=0;
              }
            }
          }
          if(spots.filter(s=>s.state==='soaped').length>=2) setPhase(PH.SCRUB);
        } else if(tool==='soap' && !atSoap && holdMs>260){
          coachSay('Soap ‡∏ó‡∏µ‡πà Soap Rack ‡∏Ñ‡∏∏‡πâ‡∏°‡∏™‡∏∏‡∏î ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÉ‡∏ä‡πâ Bubble ‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡∏ß‡πà‡∏≤‡πÅ‡∏•‡∏∞‡πÄ‡∏Ç‡πâ‡∏°‡∏Ç‡πâ‡∏ô‡∏Å‡∏ß‡πà‡∏≤');
        }
      }

      // Phase SCRUB
      if(phase===PH.SCRUB){
        if(tool==='scrub'){
          for(const s of spots){
            if(s.state==='soaped'){
              applySeq(s,'scrub');
              const need = s.hold * d.holdMul * (bubble<18?1.25:1.0) * (heat>75?1.15:1.0);
              bubble -= dt/1000 * 7 * s.weight;
              s.prog = clamp(s.prog + dt/need, 0, 1);
              if(s.prog>=1){
                s.state='cleanCandidate'; s.prog=0;
                s.cleaned=true;

                // B) Mission 1 progress
                const m1 = missions.find(m=>m.id==='m1');
                if(m1 && m1.targets.includes(s.id)){
                  // count unique completion
                  if(!m1._doneSet) m1._doneSet = {};
                  if(!m1._doneSet[s.id]){
                    m1._doneSet[s.id]=true;
                    missionAddDone('m1',1);
                    coachSay(`‡∏ó‡∏≥‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ${s.name} ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ñ‡∏π‡∏Ñ‡∏£‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏•‡πâ‡∏ß`);
                  }
                }

                // boss damage
                if(boss && boss.spotId===s.id){
                  if(boss.type==='oil' && boss.armor>0){
                    boss.armor--;
                    damageBoss(22);
                    coachSay('‡∏•‡∏≠‡∏Å‡∏ä‡∏±‡πâ‡∏ô‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: Wet+Soap ‡∏Å‡πà‡∏≠‡∏ô Scrub ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏´‡∏•‡∏∏‡∏î‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡∏±‡πâ‡∏ô');
                  } else {
                    damageBoss(30);
                  }
                }
              }
            } else if(s.state==='revealed'){
              s.shinyNotClean = true;
            }
          }
          const anySoaped = spots.some(s=>s.state==='soaped');
          const anyCandidate = spots.some(s=>s.state==='cleanCandidate');
          if(!anySoaped && anyCandidate) setPhase(PH.RINSE);
        }
      }

      // Phase RINSE
      if(phase===PH.RINSE){
        if(tool==='rinse' && atShower){
          heat = clamp(heat - dt/1000*0.50, 0, 100);
          for(const s of spots){
            if(s.state==='cleanCandidate'){
              applySeq(s,'rinse');
              if(s.shinyNotClean || heat>82){
                STATS.residuePenalty += 6;
                s.mistakes++;
                s.state='soaped';
                s.shinyNotClean=false;
                coachSay(`Residue ‡∏û‡∏ö‡∏ó‡∏µ‡πà ${s.name} ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ñ‡∏π‡πÄ‡∏£‡πá‡∏ß‡πÑ‡∏õ/‡∏£‡πâ‡∏≠‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏≤‡∏ö‡∏¢‡∏±‡∏á‡πÄ‡∏Å‡∏≤‡∏∞`);
              } else {
                s.state='rinsed';
              }
            }
          }
          if(allRinsed()) setPhase(PH.DRY);
        } else if(tool==='rinse' && !atShower && holdMs>260){
          coachSay('Rinse ‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡πÉ‡∏ô Shower ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÑ‡∏°‡πà‡∏•‡πâ‡∏≤‡∏á‡∏ü‡∏≠‡∏á = residue ‡∏ï‡∏¥‡∏î‡∏•‡∏ö');
        }
      }

      // Phase DRY
      if(phase===PH.DRY){
        if(tool==='dry' && atTowel){
          heat = clamp(heat - dt/1000*0.15, 0, 100);
          for(const s of spots){
            if(s.state==='rinsed'){
              applySeq(s,'dry');
              s.prog = clamp(s.prog + dt/1000 * 0.70, 0, 1);
              if(s.prog>=1){ s.state='dried'; s.prog=0; }
            }
          }
          if(spots.every(s=>s.state==='dried' || s.state==='done')) setPhase(PH.DRESS);
        } else if(tool==='dry' && !atTowel && holdMs>260){
          coachSay('Dry ‡∏ó‡∏µ‡πà Towel ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏∑‡πâ‡∏ô ‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö‡∏ä‡∏∑‡πâ‡∏ô‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡∏£‡∏≤');
        }
      }

      // Phase DRESS
      if(phase===PH.DRESS){
        if(atBasket){
          const wetLeft = spots.filter(s=>s.state!=='dried' && s.state!=='done').length;
          if(wetLeft>0){ STATS.fungusRisk += wetLeft*6; }
          if(heat>75) STATS.fungusRisk += 8;

          for(const s of spots){
            if(s.state==='dried'){
              applySeq(s,'dress');
              s.state='done';
            }
          }
          endGame(true);
        } else if(holdMs>280){
          coachSay('‡πÑ‡∏õ Basket ‡πÄ‡∏û‡∏∑‡πà‡∏≠ Dress ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÉ‡∏™‡πà‡πÄ‡∏™‡∏∑‡πâ‡∏≠‡∏ú‡πâ‡∏≤‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏õ‡∏¥‡∏î‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à');
        }
      }
    } // holding end

    // Boss spawn
    if(phase>=PH.SOAP && phase<=PH.RINSE) maybeSpawnBoss();

    // B) Missions 2 and 3 are evaluated at end; still show live partial
    // Live mission 2: mark done temporarily when heat <= threshold for a while (simple)
    const m2 = missions.find(m=>m.id==='m2');
    if(m2 && heat <= m2.threshold) m2.done = 1; else if(m2) m2.done = 0;

    const m3 = missions.find(m=>m.id==='m3');
    if(m3 && STATS.residuePenalty <= m3.limit) m3.done = 1; else if(m3) m3.done = 0;

    updateMissionUI();

    // C) Coach check (rate-limited)
    if(Math.random()<0.02) { /* do nothing: avoid spam */ }
    coachCheck();

    // timeout
    if(tLeft<=0 && phase!==PH.DONE){
      endGame(false);
    }

    // UI
    timeLbl.textContent = String(Math.ceil(tLeft));
    heatLbl.textContent = String(Math.round(heat));
    bubLbl.textContent  = String(Math.round(bubble));
    comboLbl.textContent = 'x' + combo.toFixed(1);
    heatFill.style.width = (heat)+'%';
    bubFill.style.width  = (Math.min(100, (bubble/100)*100))+'%';
  }

  // ---------- Render ----------
  function render(){
    ctx.clearRect(0,0,W,H);

    // floor base
    ctx.fillStyle = '#06102a';
    ctx.fillRect(0,0,W,H);

    // A) wet floor glow region
    ctx.globalAlpha = 0.20;
    radialFill(WET_FLOOR.x, WET_FLOOR.y, WET_FLOOR.r, 'rgba(120,200,255,.28)', 'rgba(120,200,255,0)');
    ctx.globalAlpha = 1;

    // tiles
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = '#ffffff';
    for(let x=0;x<=W;x+=TILE){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<=H;y+=TILE){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.globalAlpha = 1;

    // obstacles
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(GRID[y][x]!==1) continue;
        ctx.fillStyle = 'rgba(255,255,255,.06)';
        ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        ctx.strokeStyle = 'rgba(255,255,255,.10)';
        ctx.strokeRect(x*TILE+0.5, y*TILE+0.5, TILE-1, TILE-1);
      }
    }

    // stations
    for(const k of Object.keys(ST)) drawStation(ST[k]);

    // player
    ctx.fillStyle = 'rgba(120,200,255,.95)';
    ctx.beginPath(); ctx.arc(P.x,P.y,P.r,0,Math.PI*2); ctx.fill();

    // aura
    ctx.strokeStyle = holding ? 'rgba(255,255,255,.28)' : 'rgba(255,255,255,.10)';
    ctx.beginPath(); ctx.arc(P.x,P.y, 42,0,Math.PI*2); ctx.stroke();

    // spots around player
    for(const s of spots){
      const x = P.x + s.ox, y = P.y + s.oy;
      if(s.state==='hidden') continue;

      if(s.state==='revealed'){
        ctx.fillStyle = 'rgba(255,220,120,.30)'; spark(x,y, 10);
      }
      if(s.state==='soaped'){
        ctx.fillStyle = 'rgba(200,240,255,.55)'; bubbleDot(x,y, 10);
        progArc(x,y, 14, s.prog, 'rgba(200,240,255,.85)');
      }
      if(s.state==='cleanCandidate'){
        ctx.fillStyle = 'rgba(160,255,160,.55)'; glow(x,y, 10);
      }
      if(s.state==='rinsed'){
        ctx.fillStyle = 'rgba(140,210,255,.42)'; glow(x,y, 8);
      }
      if(s.state==='dried'){
        ctx.fillStyle = 'rgba(255,255,255,.28)'; glow(x,y, 7);
      }
      if(s.state==='done'){
        ctx.fillStyle = 'rgba(108,255,159,.22)'; glow(x,y, 6);
      }

      if(boss && boss.spotId===s.id){
        ctx.strokeStyle = 'rgba(255,90,120,.85)';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(x,y, 18,0,Math.PI*2); ctx.stroke();
        ctx.lineWidth = 1;
        if(boss.type==='oil' && boss.armor>0){
          ctx.fillStyle = 'rgba(255,90,120,.20)';
          ctx.font = '900 12px system-ui';
          ctx.fillText('ARMOR '+boss.armor, x-24, y-22);
        }
      }
    }

    // overlay info
    ctx.fillStyle = 'rgba(255,255,255,.06)';
    ctx.fillRect(10,10, 320, 34);
    ctx.fillStyle = '#e8ecff';
    ctx.font = '800 13px system-ui';
    ctx.fillText(`Tool:${tool.toUpperCase()} UV:${scanLeft} Boss:${boss?boss.type:'‚Äî'} Slips:${STATS.slips}`, 18, 32);
  }

  function radialFill(x,y,r, c1, c2){
    const g = ctx.createRadialGradient(x,y, 0, x,y, r);
    g.addColorStop(0, c1);
    g.addColorStop(1, c2);
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }

  function drawStation(s){
    ctx.fillStyle = 'rgba(255,255,255,.05)';
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,.14)';
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,.78)';
    ctx.font = '800 13px system-ui';
    ctx.fillText(s.label, s.x - s.r + 10, s.y + 4);
  }

  function spark(x,y,n){
    for(let i=0;i<n;i++){
      const a = i/n*Math.PI*2;
      const rr = 6 + (i%3)*2;
      ctx.globalAlpha = 0.35;
      ctx.beginPath();
      ctx.arc(x+Math.cos(a)*rr, y+Math.sin(a)*rr, 2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
  function glow(x,y,r){
    ctx.globalAlpha = 0.65;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }
  function bubbleDot(x,y,r){
    ctx.globalAlpha = 0.75;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }
  function progArc(x,y,r,p,color){
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(x,y,r, -Math.PI/2, -Math.PI/2 + Math.PI*2*p);
    ctx.stroke();
    ctx.lineWidth = 1;
  }

  // ---------- End game + scoring + heatmap ----------
  function endGame(completed){
    // finalize missions
    missionFinalize();
    const mBonus = missionBonusTotal();

    const doneCount = spots.filter(s=>s.state==='done').length;
    const cleanedCount = spots.filter(s=>s.cleaned).length;
    const base = doneCount*22 + cleanedCount*10;
    const comboBonus = Math.round((combo-1.0)*50);
    const bossBonus = STATS.bossKilled*25;

    const totalSeq = STATS.seqOk + STATS.seqBad;
    const seqRate = totalSeq>0 ? (STATS.seqOk/totalSeq) : 0.0;
    const grade = seqRate>=0.90 ? 'A' : seqRate>=0.78 ? 'B' : seqRate>=0.64 ? 'C' : 'D';

    if(!completed){
      const notDry = spots.filter(s=>s.state!=='done').length;
      STATS.fungusRisk += notDry*4;
      STATS.residuePenalty += Math.round((100-heat)/20);
    }

    const residue = Math.round(STATS.residuePenalty);
    const fungus  = Math.round(STATS.fungusRisk);
    const mistakes = STATS.wrongOrder + STATS.regrowCount + STATS.spreadCount;

    const total = Math.max(0,
      Math.round(base + comboBonus + bossBonus + mBonus
        - residue*1.2 - fungus*1.1 - mistakes*2 - (STATS.slips*0.5))
    );

    phase = PH.DONE;
    phaseLbl.textContent = 'DONE';
    resultEl.style.display='block';

    // KPIs
    kpiEl.innerHTML = '';
    const addK = (k,v)=> {
      const s = document.createElement('span');
      s.className='pill';
      s.innerHTML = `${k}: <b>${v}</b>`;
      kpiEl.appendChild(s);
    };
    addK('Total', total);
    addK('Clean', base);
    addK('Combo+', comboBonus);
    addK('Boss+', bossBonus);
    addK('Mission+', mBonus);
    addK('Residue-', residue);
    addK('Fungus-', fungus);
    addK('Slips', STATS.slips);

    seqGradeEl.textContent = `Grade ${grade} (Seq OK ${(seqRate*100).toFixed(0)}%)`;
    notesEl.textContent =
      `Regrow ${STATS.regrowCount}, Spread ${STATS.spreadCount}, UV ${STATS.scansUsed}, Heat ${Math.round(heat)}.`;

    resSubEl.textContent = completed ? '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏≠‡∏≤‡∏ö‡∏Ñ‡∏£‡∏ö‡∏•‡∏≥‡∏î‡∏±‡∏ö + ‡∏ú‡πà‡∏≤‡∏ô‡∏°‡∏¥‡∏ä‡∏ä‡∏±‡πà‡∏ô‡πÑ‡∏î‡πâ‡πÇ‡∏ö‡∏ô‡∏±‡∏™' : '‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤ ‚Äî ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏´‡πâ‡∏•‡∏∑‡πà‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô';

    drawHeatmap(grade, total);

    const byMist = [...spots].sort((a,b)=> (b.mistakes||0)-(a.mistakes||0));
    const top = byMist.slice(0,3).map(s=> `${s.name} (${s.mistakes||0})`).join(', ');
    mistakesEl.textContent = 'Top mistakes: ' + (top || '‚Äî');
  }

  function missionFinalize(){
    const m2 = missions.find(m=>m.id==='m2');
    const m3 = missions.find(m=>m.id==='m3');
    if(m2 && heat <= m2.threshold) m2.done = m2.need;
    if(m3 && STATS.residuePenalty <= m3.limit) m3.done = m3.need;
    updateMissionUI();
  }
  function missionBonusTotal(){
    let b=0;
    for(const m of missions){ if(m.done>=m.need) b += m.bonus; }
    return b;
  }

  function drawHeatmap(grade, total){
    silCtx.clearRect(0,0,silCv.width,silCv.height);
    silCtx.fillStyle = 'rgba(255,255,255,.03)';
    silCtx.fillRect(0,0,silCv.width,silCv.height);

    const cx = silCv.width/2, cy = silCv.height/2 + 10;
    silCtx.fillStyle = 'rgba(255,255,255,.07)';
    silCtx.beginPath(); silCtx.arc(cx, cy-150, 42, 0, Math.PI*2); silCtx.fill();
    roundRectFill(silCtx, cx-70, cy-110, 140, 210, 40);
    roundRectFill(silCtx, cx-60, cy+100, 50, 150, 26);
    roundRectFill(silCtx, cx+10, cy+100, 50, 150, 26);
    roundRectFill(silCtx, cx-120, cy-90, 45, 165, 20);
    roundRectFill(silCtx, cx+75,  cy-90, 45, 165, 20);

    const POS = {
      behindEar: { x: cx-28, y: cy-160 },
      neckBack:  { x: cx+18, y: cy-145 },
      armpit:    { x: cx-84, y: cy-70 },
      elbowFold: { x: cx+98, y: cy-20 },
      belly:     { x: cx,    y: cy-10 },
      backKnee:  { x: cx-34, y: cy+170 },
      toes:      { x: cx+34, y: cy+250 },
    };

    for(const s of spots){
      const p = POS[s.id] || {x:cx,y:cy};
      const clean = (s.state==='done');
      const warn = (!clean && (s.mistakes||0)>0);
      const risk = (!clean && (s.state==='soaped' || s.state==='revealed' || s.state==='hidden'));
      const col = clean ? 'rgba(108,255,159,.85)'
                : warn ? 'rgba(255,220,120,.85)'
                : risk ? 'rgba(255,90,120,.85)'
                : 'rgba(140,210,255,.65)';
      silCtx.fillStyle = col;
      silCtx.beginPath(); silCtx.arc(p.x,p.y, 12, 0, Math.PI*2); silCtx.fill();
      silCtx.strokeStyle = 'rgba(0,0,0,.25)';
      silCtx.stroke();
      silCtx.fillStyle = 'rgba(255,255,255,.80)';
      silCtx.font = '900 12px system-ui';
      silCtx.fillText(s.name, p.x+16, p.y+4);
    }

    silCtx.fillStyle = 'rgba(255,255,255,.70)';
    silCtx.font = '900 14px system-ui';
    silCtx.fillText(`Total ${total} | Grade ${grade} | Mission+ ${missionBonusTotal()}`, 14, silCv.height-14);
  }

  function roundRectFill(c, x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y, x+w,y+h, r);
    c.arcTo(x+w,y+h, x,y+h, r);
    c.arcTo(x,y+h, x,y, r);
    c.arcTo(x,y, x+w,y, r);
    c.closePath();
    c.fill();
  }

  // ---------- Coach check ----------
  const COACH = { lastAt:-9999, cooldownMs:1400, lastMsg:'' };
  function coachSay(msg){
    const now = performance.now();
    if(now-COACH.lastAt < COACH.cooldownMs && msg===COACH.lastMsg) return;
    COACH.lastAt = now; COACH.lastMsg = msg;
    coach.textContent = 'Tip: ' + msg;
  }
  function coachCheck(){
    if(phase===PH.WET){
      if(!inZone(P.x,P.y, ST.shower)) coachSay('Wet ‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡πÉ‡∏ô Shower ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÄ‡∏õ‡∏µ‡∏¢‡∏Å‡πÑ‡∏°‡πà‡∏ó‡∏±‡πà‡∏ß ‡∏ü‡∏≠‡∏Å‡πÑ‡∏°‡πà‡∏ï‡∏¥‡∏î');
      else if(tool!=='water') coachSay('‡∏≠‡∏¢‡∏π‡πà Shower ‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏ä‡πâ Water ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏•‡∏î Heat ‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö');
    }
    if(phase===PH.SOAP){
      if(!inZone(P.x,P.y, ST.soap)) coachSay('‡πÑ‡∏õ Soap Rack ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ü‡∏≠‡∏Å‡πÑ‡∏î‡πâ‡πÅ‡∏£‡∏á‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î Bubble');
      if(tool!=='soap') coachSay('Phase Soap: ‡πÉ‡∏ä‡πâ Soap ‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡∏π ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏Å‡∏±‡∏ô ‚Äú‡∏õ‡∏•‡∏≠‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‚Äù');
    }
    if(phase===PH.SCRUB){
      const soaped = spots.filter(s=>s.state==='soaped');
      if(!soaped.length) coachSay('‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà Soap ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ï‡πâ‡∏≠‡∏á‡∏ü‡∏≠‡∏Å‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡∏π');
      if(tool!=='scrub') coachSay('Phase Scrub: ‡πÉ‡∏ä‡πâ Scrub ‡πÅ‡∏•‡∏∞‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤');
      if(bubble<18) coachSay('Bubble ‡∏ï‡πà‡∏≥ ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ñ‡∏π‡∏à‡∏∞‡∏ä‡πâ‡∏≤ ‡∏•‡∏≠‡∏á Shower ‡∏•‡∏î Heat ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡∏ï‡πà‡∏≠');
    }
    if(phase===PH.RINSE){
      if(!inZone(P.x,P.y, ST.shower)) coachSay('Rinse ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏•‡∏±‡∏ö Shower ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÑ‡∏°‡πà‡∏•‡πâ‡∏≤‡∏á‡∏ü‡∏≠‡∏á = residue ‡∏ï‡∏¥‡∏î‡∏•‡∏ö');
    }
    if(phase===PH.DRY){
      if(!inZone(P.x,P.y, ST.towel)) coachSay('Dry ‡∏ó‡∏µ‡πà Towel ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ä‡∏∑‡πâ‡∏ô = fungus risk ‡πÄ‡∏û‡∏¥‡πà‡∏°');
    }
  }

  // ---------- Boss update ----------
  function updateBoss(dt){
    if(!boss) return;
    boss.pulseT += dt;
    boss.spreadT += dt;
    if(boss.pulseT>1500){
      boss.pulseT=0;
      heat = clamp(heat + (boss.type==='stink'?4:3), 0, 100);
      STATS.residuePenalty += (boss.type==='stink'?2:1);
    }
    if(boss.spreadT>(boss.type==='stink'?2400:2800)){
      boss.spreadT=0;
      const hidden = spots.find(s=>s.state==='hidden');
      if(hidden){ hidden.state='revealed'; hidden.wetUnlocked=true; STATS.spreadCount++; }
      else {
        const c = spots.find(s=>s.state==='cleanCandidate' || s.state==='rinsed');
        if(c){ c.state='soaped'; c.prog=0; c.shinyNotClean=true; STATS.regrowCount++; }
      }
    }
  }
  function maybeSpawnBoss(){
    if(boss) return;
    const d = DIFF[diffSel.value] || DIFF.normal;
    const trigger = (heat > 72) || (STATS.wrongOrder >= 2) || (tLeft < d.time*0.55 && !allCleanCandidate());
    if(!trigger) return;
    if(rng() > d.bossChance) return;
    let s = spots.find(x=>x.state==='revealed' || x.state==='soaped') || spots[0];
    if(s.state==='hidden'){ s.state='revealed'; s.wetUnlocked=true; }
    const type = (rng()<0.5) ? 'stink' : 'oil';
    boss = { type, spotId:s.id, hp:(type==='stink'?100:120), armor:(type==='oil'?3:0), pulseT:0, spreadT:0 };
    coachSay(type==='stink'
      ? '‚ö†Ô∏è Stink Monster: ‡∏ï‡πâ‡∏≠‡∏á‡∏•‡πâ‡∏≤‡∏á‡∏ñ‡∏π‡∏Å‡∏•‡∏≥‡∏î‡∏±‡∏ö ‡πÑ‡∏°‡πà‡∏á‡∏±‡πâ‡∏ô Heat ‡∏à‡∏∞‡∏û‡∏∏‡πà‡∏á'
      : '‚ö†Ô∏è Oil Boss: ‡∏ï‡πâ‡∏≠‡∏á Wet ‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡∏∂‡∏á‡∏ñ‡∏π‡∏à‡∏∞‡∏•‡∏≠‡∏Å‡∏ä‡∏±‡πâ‡∏ô‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô');
  }
  function damageBoss(amount){
    if(!boss) return;
    boss.hp -= amount;
    if(boss.hp<=0){
      STATS.bossKilled++;
      bubble = clamp(bubble + 18, 0, 140);
      heat = clamp(heat - 14, 0, 100);
      boss=null;
      coachSay('‚úÖ Boss ‡∏ñ‡∏π‡∏Å‡∏ä‡∏≥‡∏£‡∏∞! ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ó‡∏≥‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Ñ‡∏£‡∏ö ‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏™‡∏∞‡∏™‡∏°‡∏Ñ‡∏£‡∏≤‡∏ö‡πÉ‡∏ô‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö');
    }
  }

  // ---------- Sequence ----------
  function seqStepOk(prev,next){
    const order=['none','wet','soap','scrub','rinse','dry','dress'];
    return order.indexOf(next)===order.indexOf(prev)+1;
  }
  function applySeq(spot, step){
    if(seqStepOk(spot.lastStep, step)){
      spot.lastStep=step;
      STATS.seqOk++;
      combo = clamp(combo + 0.03, 1.0, 2.0);
      return true;
    }
    STATS.seqBad++; STATS.wrongOrder++;
    combo = clamp(combo - 0.06, 1.0, 2.0);
    const roll=rng();
    if(roll<0.55){
      STATS.regrowCount++; spot.mistakes++;
      if(spot.state==='soaped' || spot.state==='scrubbing') spot.state='revealed';
      if(spot.state==='cleanCandidate') spot.state='soaped';
      spot.prog=0;
      heat = clamp(heat+3,0,100);
      coachSay(`‡∏ú‡∏¥‡∏î‡∏•‡∏≥‡∏î‡∏±‡∏ö ‚Üí ‡∏Ñ‡∏£‡∏≤‡∏ö‡∏ü‡∏∑‡πâ‡∏ô‡∏ï‡∏±‡∏ß (${spot.name}) ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏Ç‡πâ‡∏≤‡∏°‡∏Ç‡∏±‡πâ‡∏ô`);
    } else {
      STATS.spreadCount++; heat = clamp(heat+4,0,100);
      const hidden = spots.find(s=>s.state==='hidden');
      if(hidden){ hidden.state='revealed'; hidden.wetUnlocked=true; }
      STATS.residuePenalty += 2;
      coachSay('‡∏ú‡∏¥‡∏î‡∏•‡∏≥‡∏î‡∏±‡∏ö ‚Üí ‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢ ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÑ‡∏õ‡∏Ç‡∏±‡πâ‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ‡∏Å‡πà‡∏≠‡∏ô‡∏•‡πâ‡∏≤‡∏á‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö');
    }
    return false;
  }

  function allCleanCandidate(){
    return spots.every(s=> ['cleanCandidate','rinsed','dried','done'].includes(s.state));
  }
  function allRinsed(){
    return spots.every(s=> ['rinsed','dried','done'].includes(s.state));
  }

  // ---------- Tools ----------
  [...toolsEl.querySelectorAll('button[data-tool]')].forEach(b=>{
    b.addEventListener('click', ()=> setTool(b.dataset.tool));
  });
  function setTool(t){
    tool=t;
    [...toolsEl.querySelectorAll('button[data-tool]')].forEach(x=>x.classList.toggle('sel', x.dataset.tool===tool));
    tipForTool();
  }
  function tipForTool(){
    if(phase===PH.DONE) return;
    if(tool==='water') coachSay('Water ‡πÉ‡∏ô Shower: ‡∏•‡∏î Heat ‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö');
    if(tool==='soap') coachSay('Soap ‡∏ó‡∏µ‡πà Soap Rack: ‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î Bubble ‡πÅ‡∏•‡∏∞‡∏ü‡∏≠‡∏Å‡πÅ‡∏£‡∏á');
    if(tool==='scrub') coachSay('Scrub: ‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏à‡∏£‡∏¥‡∏á');
    if(tool==='rinse') coachSay('Rinse ‡πÉ‡∏ô Shower: ‡∏Å‡∏±‡∏ô residue ‡∏ï‡∏¥‡∏î‡∏•‡∏ö');
    if(tool==='dry') coachSay('Dry ‡∏ó‡∏µ‡πà Towel: ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏∑‡πâ‡∏ô ‡∏•‡∏î‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡∏£‡∏≤');
    if(tool==='scan') coachSay('UV Scan ‡∏ó‡∏µ‡πà Mirror: ‡πÄ‡∏´‡πá‡∏ô‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö (‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á)');
  }

  // ---------- Holding ----------
  function setHolding(v){ holding=v; if(!v) holdMs=0; }
  actionBtn.addEventListener('pointerdown', e=>{ actionBtn.setPointerCapture(e.pointerId); setHolding(true); });
  actionBtn.addEventListener('pointerup',   ()=> setHolding(false));
  actionBtn.addEventListener('pointercancel',()=> setHolding(false));
  cv.addEventListener('pointerdown', e=>{ cv.setPointerCapture(e.pointerId); setHolding(true); });
  cv.addEventListener('pointerup',   ()=> setHolding(false));
  cv.addEventListener('pointercancel',()=> setHolding(false));

  // ---------- Joystick ----------
  const joy = document.getElementById('joy');
  const nub = document.getElementById('nub');
  let joyOn=false, joyId=null, joyCx=0, joyCy=0, joyDx=0, joyDy=0;
  joy.addEventListener('pointerdown', e=>{
    joy.setPointerCapture(e.pointerId);
    joyOn=true; joyId=e.pointerId;
    const r = joy.getBoundingClientRect();
    joyCx = r.left + r.width/2;
    joyCy = r.top + r.height/2;
    updateJoy(e.clientX, e.clientY);
  });
  joy.addEventListener('pointermove', e=>{
    if(!joyOn || e.pointerId!==joyId) return;
    updateJoy(e.clientX, e.clientY);
  });
  joy.addEventListener('pointerup', e=>{
    if(e.pointerId!==joyId) return;
    joyOn=false; joyId=null; joyDx=joyDy=0;
    nub.style.left='48px'; nub.style.top='48px';
  });
  function updateJoy(x,y){
    const dx=x-joyCx, dy=y-joyCy;
    const m=Math.sqrt(dx*dx+dy*dy);
    const max=44;
    const nx=(m>max? dx/m*max : dx);
    const ny=(m>max? dy/m*max : dy);
    joyDx=nx/max; joyDy=ny/max;
    nub.style.left=(48+nx)+'px';
    nub.style.top =(48+ny)+'px';
  }

  // ---------- Restart hooks ----------
  diffSel.addEventListener('change', ()=> restart());
  seedInp.addEventListener('change', ()=> restart());
  playAgainBtn.addEventListener('click', ()=> restart());
  closeResBtn.addEventListener('click', ()=> { resultEl.style.display='none'; });

  // ---------- Map + zones ----------
  function makeMap(){
    const g = Array.from({length:ROWS}, ()=> Array(COLS).fill(0));
    const wall=(x,y)=>{ if(x>=0&&y>=0&&x<COLS&&y<ROWS) g[y][x]=1; };
    for(let x=0;x<COLS;x++){ wall(x,0); wall(x,ROWS-1); }
    for(let y=0;y<ROWS;y++){ wall(0,y); wall(COLS-1,y); }
    for(let x=6;x<18;x++) wall(x,6);
    for(let y=10;y<18;y++) wall(6,y);
    for(let y=15;y<18;y++) for(let x=9;x<12;x++) wall(x,y);
    for(let y=3;y<5;y++) for(let x=20;x<24;x++) wall(x,y);
    g[ROWS-1][Math.floor(COLS/2)] = 0;
    return g;
  }
  function inZone(px,py,z){
    const dx=px-z.x, dy=py-z.y;
    return dx*dx+dy*dy <= z.r*z.r;
  }
  function isBlocked(px,py,r){
    const minX=Math.floor((px-r)/TILE), maxX=Math.floor((px+r)/TILE);
    const minY=Math.floor((py-r)/TILE), maxY=Math.floor((py+r)/TILE);
    for(let ty=minY; ty<=maxY; ty++){
      for(let tx=minX; tx<=maxX; tx++){
        if(tx<0||ty<0||tx>=COLS||ty>=ROWS) return true;
        if(GRID[ty][tx]!==1) continue;
        const rx=tx*TILE, ry=ty*TILE;
        const cx=clamp(px,rx,rx+TILE), cy=clamp(py,ry,ry+TILE);
        const dx=px-cx, dy=py-cy;
        if(dx*dx+dy*dy <= r*r) return true;
      }
    }
    return false;
  }

  // ---------- Render helpers ----------
  function spark(x,y,n){
    for(let i=0;i<n;i++){
      const a=i/n*Math.PI*2;
      const rr=6+(i%3)*2;
      ctx.globalAlpha=0.35;
      ctx.beginPath(); ctx.arc(x+Math.cos(a)*rr,y+Math.sin(a)*rr,2,0,Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha=1;
  }
  function glow(x,y,r){
    ctx.globalAlpha=0.65;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;
  }
  function bubbleDot(x,y,r){
    ctx.globalAlpha=0.75;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;
  }
  function progArc(x,y,r,p,color){
    ctx.strokeStyle=color; ctx.lineWidth=3;
    ctx.beginPath(); ctx.arc(x,y,r,-Math.PI/2,-Math.PI/2+Math.PI*2*p); ctx.stroke();
    ctx.lineWidth=1;
  }
  function roundRectFill(c,x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath(); c.fill();
  }

  // ---------- Render ----------
  function render(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle='#06102a'; ctx.fillRect(0,0,W,H);

    // Wet floor glow
    ctx.globalAlpha=0.20;
    const gx=WET_FLOOR.x, gy=WET_FLOOR.y, gr=WET_FLOOR.r;
    const grad=ctx.createRadialGradient(gx,gy,0,gx,gy,gr);
    grad.addColorStop(0,'rgba(120,200,255,.28)');
    grad.addColorStop(1,'rgba(120,200,255,0)');
    ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(gx,gy,gr,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha=1;

    // tiles
    ctx.globalAlpha=0.10; ctx.strokeStyle='#fff';
    for(let x=0;x<=W;x+=TILE){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<=H;y+=TILE){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.globalAlpha=1;

    // obstacles
    for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){
      if(GRID[y][x]!==1) continue;
      ctx.fillStyle='rgba(255,255,255,.06)';
      ctx.fillRect(x*TILE,y*TILE,TILE,TILE);
      ctx.strokeStyle='rgba(255,255,255,.10)';
      ctx.strokeRect(x*TILE+0.5,y*TILE+0.5,TILE-1,TILE-1);
    }

    // stations
    for(const k of Object.keys(ST)){
      const s=ST[k];
      ctx.fillStyle='rgba(255,255,255,.05)';
      ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,.14)';
      ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.stroke();
      ctx.fillStyle='rgba(255,255,255,.78)';
      ctx.font='800 13px system-ui';
      ctx.fillText(s.label, s.x-s.r+10, s.y+4);
    }

    // player
    ctx.fillStyle='rgba(120,200,255,.95)';
    ctx.beginPath(); ctx.arc(P.x,P.y,P.r,0,Math.PI*2); ctx.fill();

    // aura
    ctx.strokeStyle = holding ? 'rgba(255,255,255,.28)' : 'rgba(255,255,255,.10)';
    ctx.beginPath(); ctx.arc(P.x,P.y,42,0,Math.PI*2); ctx.stroke();

    // spots
    for(const s of spots){
      const x=P.x+s.ox, y=P.y+s.oy;
      if(s.state==='hidden') continue;
      if(s.state==='revealed'){ ctx.fillStyle='rgba(255,220,120,.30)'; spark(x,y,10); }
      if(s.state==='soaped'){ ctx.fillStyle='rgba(200,240,255,.55)'; bubbleDot(x,y,10); progArc(x,y,14,s.prog,'rgba(200,240,255,.85)'); }
      if(s.state==='cleanCandidate'){ ctx.fillStyle='rgba(160,255,160,.55)'; glow(x,y,10); }
      if(s.state==='rinsed'){ ctx.fillStyle='rgba(140,210,255,.42)'; glow(x,y,8); }
      if(s.state==='dried'){ ctx.fillStyle='rgba(255,255,255,.28)'; glow(x,y,7); }
      if(s.state==='done'){ ctx.fillStyle='rgba(108,255,159,.22)'; glow(x,y,6); }

      if(boss && boss.spotId===s.id){
        ctx.strokeStyle='rgba(255,90,120,.85)'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.arc(x,y,18,0,Math.PI*2); ctx.stroke();
        ctx.lineWidth=1;
        if(boss.type==='oil' && boss.armor>0){
          ctx.fillStyle='rgba(255,90,120,.20)';
          ctx.font='900 12px system-ui';
          ctx.fillText('ARMOR '+boss.armor, x-24, y-22);
        }
      }
    }

    // overlay
    ctx.fillStyle='rgba(255,255,255,.06)'; ctx.fillRect(10,10, 350, 34);
    ctx.fillStyle='#e8ecff'; ctx.font='800 13px system-ui';
    ctx.fillText(`Tool:${tool.toUpperCase()} UV:${scanLeft} Boss:${boss?boss.type:'‚Äî'} Bubble:${Math.round(bubble)} Heat:${Math.round(heat)}`, 18, 32);
  }

  // ---------- Main update ----------
  function update(dt){
    if(phase===PH.DONE) return;
    const d = DIFF[diffSel.value] || DIFF.normal;

    if(phase===PH.PREP){
      prepMs -= dt;
      if(prepMs<=0) setPhase(PH.WET);
    } else {
      tLeft -= dt/1000; if(tLeft<0) tLeft=0;
      heat += (dt/1000)*d.heatRise;
      if(!holding) heat += (dt/1000)*0.10;
    }

    // wet floor slip
    const onWet = inCircle(P.x,P.y, WET_FLOOR.x, WET_FLOOR.y, WET_FLOOR.r);

    // input vector
    let mx=0,my=0;
    if(keys['arrowleft']||keys['a']) mx-=1;
    if(keys['arrowright']||keys['d']) mx+=1;
    if(keys['arrowup']||keys['w']) my-=1;
    if(keys['arrowdown']||keys['s']) my+=1;
    mx += joyDx; my += joyDy;
    const m=Math.hypot(mx,my);
    if(m>1e-3){ mx/=Math.max(1,m); my/=Math.max(1,m); }

    // velocity integrate
    const accel=900;
    const fric = onWet ? 5.5 : 10.5;
    P.vx += mx*accel*(dt/1000);
    P.vy += my*accel*(dt/1000);
    P.vx *= Math.exp(-fric*(dt/1000));
    P.vy *= Math.exp(-fric*(dt/1000));

    const vmax = onWet ? 230 : 200;
    const sp=Math.hypot(P.vx,P.vy);
    if(sp>vmax){ P.vx=P.vx/sp*vmax; P.vy=P.vy/sp*vmax; }

    // move collision
    let nx=P.x+P.vx*(dt/1000), ny=P.y;
    if(!isBlocked(nx,ny,P.r)) P.x=nx; else { P.vx*=-0.22; heat=clamp(heat+0.35,0,100); if(onWet) STATS.slips++; }
    nx=P.x; ny=P.y+P.vy*(dt/1000);
    if(!isBlocked(nx,ny,P.r)) P.y=ny; else { P.vy*=-0.22; heat=clamp(heat+0.35,0,100); if(onWet) STATS.slips++; }

    heat=clamp(heat,0,100);
    bubble=clamp(bubble,0,140);

    updateBoss(dt);

    // reveal trickle
    if(phase>=PH.WET){
      for(const s of spots){
        if(s.state==='hidden'){
          const chance=d.reveal*(inZone(P.x,P.y,ST.shower)?1.0:0.35);
          if(rng()<chance*0.005){ s.state='revealed'; s.wetUnlocked=true; }
        }
      }
    }

    // actions
    if(holding){
      holdMs += dt;
      const atShower=inZone(P.x,P.y,ST.shower);
      const atSoap=inZone(P.x,P.y,ST.soap);
      const atScan=inZone(P.x,P.y,ST.scan);
      const atTowel=inZone(P.x,P.y,ST.towel);
      const atBasket=inZone(P.x,P.y,ST.basket);

      if(tool==='scan'){
        if(atScan && holdMs>220 && scanLeft>0){
          scanLeft--; STATS.scansUsed++;
          for(const s of spots){ if(s.state==='hidden'){ s.state='revealed'; s.wetUnlocked=true; } }
          heat=clamp(heat+4,0,100);
          coachSay(`UV Scan ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö (‡πÄ‡∏´‡∏•‡∏∑‡∏≠ ${scanLeft})`);
          setHolding(false);
        } else if(!atScan && holdMs>300){
          coachSay('Scan ‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏ó‡∏µ‡πà UV Mirror ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏Ñ‡∏£‡∏≤‡∏ö');
          setHolding(false);
        }
      }

      if(phase===PH.WET){
        if(tool==='water' && atShower){
          heat=clamp(heat-dt/1000*0.55,0,100);
          for(const s of spots){
            if(s.state==='hidden' && rng()<0.012){ s.state='revealed'; s.wetUnlocked=true; }
            if(s.state==='revealed'){ applySeq(s,'wet'); }
          }
          const wetCount=spots.filter(s=>s.lastStep==='wet').length;
          if(wetCount>=3) setPhase(PH.SOAP);
        } else if(tool==='water' && !atShower && holdMs>260){
          coachSay('Wet ‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡πÉ‡∏ô Shower ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÄ‡∏õ‡∏µ‡∏¢‡∏Å‡πÑ‡∏°‡πà‡∏ó‡∏±‡πà‡∏ß ‡∏ü‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏ï‡∏¥‡∏î');
        }
      }

      if(phase===PH.SOAP){
        if(tool==='soap' && atSoap){
          for(const s of spots){
            if(s.state==='revealed'){
              applySeq(s,'soap');
              bubble -= dt/1000*10*s.weight;
              s.prog = clamp(s.prog + dt/1000*0.70,0,1);
              if(s.prog>=1){ s.state='soaped'; s.prog=0; }
            }
          }
          if(spots.filter(s=>s.state==='soaped').length>=2) setPhase(PH.SCRUB);
        } else if(tool==='soap' && !atSoap && holdMs>260){
          coachSay('Soap ‡∏ó‡∏µ‡πà Soap Rack ‡∏Ñ‡∏∏‡πâ‡∏°‡∏™‡∏∏‡∏î ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î Bubble ‡πÅ‡∏•‡∏∞‡πÅ‡∏£‡∏á‡∏Å‡∏ß‡πà‡∏≤');
        }
      }

      if(phase===PH.SCRUB){
        if(tool==='scrub'){
          for(const s of spots){
            if(s.state==='soaped'){
              applySeq(s,'scrub');
              const need=s.hold*d.holdMul*(bubble<18?1.25:1.0)*(heat>75?1.15:1.0);
              bubble -= dt/1000*7*s.weight;
              s.prog = clamp(s.prog + dt/need,0,1);
              if(s.prog>=1){
                s.state='cleanCandidate'; s.prog=0; s.cleaned=true;

                // mission 1
                const m1=missions.find(m=>m.id==='m1');
                if(m1 && m1.targets.includes(s.id)){
                  if(!m1._doneSet) m1._doneSet={};
                  if(!m1._doneSet[s.id]){ m1._doneSet[s.id]=true; missionAddDone('m1',1); }
                }

                // boss dmg
                if(boss && boss.spotId===s.id){
                  if(boss.type==='oil' && boss.armor>0){ boss.armor--; damageBoss(22); }
                  else damageBoss(30);
                }
              }
            } else if(s.state==='revealed'){
              s.shinyNotClean=true;
            }
          }
          const anySoaped=spots.some(s=>s.state==='soaped');
          const anyCandidate=spots.some(s=>s.state==='cleanCandidate');
          if(!anySoaped && anyCandidate) setPhase(PH.RINSE);
        }
      }

      if(phase===PH.RINSE){
        if(tool==='rinse' && atShower){
          heat=clamp(heat-dt/1000*0.50,0,100);
          for(const s of spots){
            if(s.state==='cleanCandidate'){
              applySeq(s,'rinse');
              if(s.shinyNotClean || heat>82){
                STATS.residuePenalty += 6;
                s.mistakes++;
                s.state='soaped'; s.shinyNotClean=false;
              } else {
                s.state='rinsed';
              }
            }
          }
          if(allRinsed()) setPhase(PH.DRY);
        } else if(tool==='rinse' && !atShower && holdMs>260){
          coachSay('Rinse ‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡πÉ‡∏ô Shower ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÑ‡∏°‡πà‡∏•‡πâ‡∏≤‡∏á‡∏ü‡∏≠‡∏á = residue');
        }
      }

      if(phase===PH.DRY){
        if(tool==='dry' && atTowel){
          heat=clamp(heat-dt/1000*0.15,0,100);
          for(const s of spots){
            if(s.state==='rinsed'){
              applySeq(s,'dry');
              s.prog=clamp(s.prog+dt/1000*0.70,0,1);
              if(s.prog>=1){ s.state='dried'; s.prog=0; }
            }
          }
          if(spots.every(s=>s.state==='dried' || s.state==='done')) setPhase(PH.DRESS);
        } else if(tool==='dry' && !atTowel && holdMs>260){
          coachSay('Dry ‡∏ó‡∏µ‡πà Towel ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏∑‡πâ‡∏ô ‡∏•‡∏î‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡∏£‡∏≤');
        }
      }

      if(phase===PH.DRESS){
        if(atBasket){
          const wetLeft=spots.filter(s=>s.state!=='dried' && s.state!=='done').length;
          if(wetLeft>0) STATS.fungusRisk += wetLeft*6;
          if(heat>75) STATS.fungusRisk += 8;
          for(const s of spots){
            if(s.state==='dried'){ applySeq(s,'dress'); s.state='done'; }
          }
          endGame(true);
        } else if(holdMs>280){
          coachSay('‡πÑ‡∏õ Basket ‡πÄ‡∏û‡∏∑‡πà‡∏≠ Dress ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏õ‡∏¥‡∏î‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à‡πÅ‡∏•‡∏∞‡∏Å‡∏±‡∏ô‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢');
        }
      }
    }

    // boss spawn
    if(phase>=PH.SOAP && phase<=PH.RINSE) maybeSpawnBoss();

    // missions live update (m2/m3)
    const m2=missions.find(m=>m.id==='m2'); if(m2) m2.done = (heat<=m2.threshold ? 1 : 0);
    const m3=missions.find(m=>m.id==='m3'); if(m3) m3.done = (STATS.residuePenalty<=m3.limit ? 1 : 0);
    updateMissionUI();

    // coach periodic check
    coachCheck();

    // timeout
    if(tLeft<=0 && phase!==PH.DONE) endGame(false);

    // UI
    timeLbl.textContent=String(Math.ceil(tLeft));
    heatLbl.textContent=String(Math.round(heat));
    bubLbl.textContent=String(Math.round(bubble));
    comboLbl.textContent='x'+combo.toFixed(1);
    heatFill.style.width=(heat)+'%';
    bubFill.style.width=(Math.min(100,(bubble/100)*100))+'%';
  }

  // ---------- Loop ----------
  let last = performance.now();
  restart();
  requestAnimationFrame(loop);
  function loop(now){
    const dt=now-last; last=now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  // ---------- Restart ----------
  function restart(){
    GRID = makeMap();
    rng = makeRng(seedInp.value.trim() || '20260219');
    const d = DIFF[diffSel.value] || DIFF.normal;
    heat=0; bubble=d.bubble; tLeft=d.time; combo=1.0;
    prepMs=2200; phase=PH.PREP; boss=null;
    for(const k of Object.keys(STATS)) STATS[k]=0;
    scanLeft=d.scanLeft;
    spawnSpots();
    makeMissions();
    P.x=5*TILE; P.y=16*TILE; P.vx=0; P.vy=0;
    resultEl.style.display='none';
    setTool('water');
    setPhase(PH.PREP);
    coachSay('‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏•‡∏¢! ‡πÑ‡∏õ Shower ‡∏Å‡πà‡∏≠‡∏ô (‡∏£‡∏∞‡∏ß‡∏±‡∏á‡∏û‡∏∑‡πâ‡∏ô‡πÄ‡∏õ‡∏µ‡∏¢‡∏Å‡∏•‡∏∑‡πà‡∏ô)');
  }

})();
</script>
</body>
</html>