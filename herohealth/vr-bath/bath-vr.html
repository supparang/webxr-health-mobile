<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>HeroHealth ‚Äî Bath Hidden Dirt Quest (Top-down, PC/Mobile) vABC-123</title>
<style>
  :root{ --bg:#0b1020; --panel:#121a33; --txt:#e8ecff; --muted:#9aa6d6; --acc:#78c8ff; --bad:#ff5a78; --good:#6cff9f; }
  html,body{ height:100%; }
  body{ margin:0; background:var(--bg); color:var(--txt); font-family:system-ui,Segoe UI,Arial; }
  #wrap{ display:grid; grid-template-rows:auto 1fr auto; height:100dvh; }
  #hud{
    display:flex; gap:10px; align-items:center; padding:10px 12px;
    background:linear-gradient(180deg, rgba(18,26,51,.98), rgba(18,26,51,.70));
    border-bottom:1px solid rgba(255,255,255,.08);
    flex-wrap:wrap;
  }
  .pill{ padding:6px 10px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10); border-radius:999px; }
  .bar{ width:140px; height:10px; background:rgba(255,255,255,.08); border-radius:999px; overflow:hidden; display:inline-block; vertical-align:middle; }
  .fill{ height:100%; width:50%; background:rgba(120,200,255,.9); }
  #coach{ color:var(--muted); }
  #game{ position:relative; display:flex; justify-content:center; align-items:center; overflow:hidden; }
  canvas{ width:min(100vw, 860px); height:min(74vh, 580px); background:#071022; border:1px solid rgba(255,255,255,.12); border-radius:16px; touch-action:none; }
  #toolbar{
    display:flex; gap:8px; padding:10px 12px;
    background:linear-gradient(0deg, rgba(18,26,51,.98), rgba(18,26,51,.70));
    border-top:1px solid rgba(255,255,255,.08);
    align-items:center; justify-content:space-between;
  }
  .tools{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  button, select, input{
    background:rgba(255,255,255,.06); color:var(--txt);
    border:1px solid rgba(255,255,255,.14);
    border-radius:12px; padding:10px 12px; font-weight:800;
  }
  button.sel{ outline:2px solid rgba(120,200,255,.9); }
  #actionBtn{ padding:12px 16px; border-radius:16px; }
  #joy{ position:absolute; left:14px; bottom:14px; width:128px; height:128px; border-radius:64px;
        background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.10); display:none; }
  #nub{ position:absolute; left:48px; top:48px; width:32px; height:32px; border-radius:16px;
        background:rgba(120,200,255,.5); border:1px solid rgba(120,200,255,.9); }
  @media (pointer:coarse){ #joy{ display:block; } }

  /* Missions */
  #missions{
    display:flex; gap:10px; flex-wrap:wrap; align-items:center;
  }
  .mcard{
    min-width:220px;
    background:rgba(255,255,255,.05);
    border:1px solid rgba(255,255,255,.10);
    border-radius:14px;
    padding:8px 10px;
  }
  .mrow{ display:flex; justify-content:space-between; gap:8px; font-size:12px; color:var(--muted); }
  .mttl{ font-weight:900; color:var(--txt); }
  .mbar{ height:8px; background:rgba(255,255,255,.08); border-radius:999px; overflow:hidden; margin-top:6px; }
  .mfill{ height:100%; width:0%; background:rgba(108,255,159,.85); }

  /* Result overlay */
  #result{
    position:absolute; inset:0; display:none;
    background:rgba(7,16,34,.92);
    padding:18px; overflow:auto;
  }
  #result .card{
    max-width:860px; margin:0 auto; background:rgba(18,26,51,.88);
    border:1px solid rgba(255,255,255,.12); border-radius:18px; padding:14px;
  }
  #grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; }
  @media (max-width:860px){ #grid2{ grid-template-columns: 1fr; } }
  .h2{ font-size:18px; font-weight:900; margin:6px 0 10px; }
  .muted{ color:var(--muted); }
  .kpi{ display:flex; gap:10px; flex-wrap:wrap; }
  .kpi .pill{ background:rgba(255,255,255,.05); }
  #sil{ width:100%; height:auto; background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.10); border-radius:14px; }

  /* Big overlay for Practice / Mini-quest */
  #overlay{
    position:absolute; inset:0; display:none;
    background:rgba(7,16,34,.86);
    padding:18px;
  }
  #overlay .card{
    max-width:720px; margin:0 auto;
    background:rgba(18,26,51,.90);
    border:1px solid rgba(255,255,255,.12);
    border-radius:18px;
    padding:14px;
  }
  #overlay .big{
    font-size:46px; font-weight:1000; letter-spacing:.5px;
  }
</style>
</head>
<body>
<div id="wrap">
  <div id="hud">
    <span class="pill">Mode: <b id="modeLbl">PRACTICE</b></span>
    <span class="pill">Phase: <b id="phaseLbl">PREP</b></span>
    <span class="pill">Time: <b id="timeLbl">80</b>s</span>
    <span class="pill">Heat <span class="bar"><span class="fill" id="heatFill"></span></span> <b id="heatLbl">0</b></span>
    <span class="pill">Bubble <span class="bar"><span class="fill" id="bubFill"></span></span> <b id="bubLbl">100</b></span>
    <span class="pill">Combo: <b id="comboLbl">x1.0</b></span>
    <span class="pill">Debuff: <b id="debLbl">‚Äî</b></span>

    <div id="missions" style="width:100%;">
      <div class="mcard">
        <div class="mrow"><span class="mttl" id="m1t">Mission 1</span><span id="m1s">0/1</span></div>
        <div class="mbar"><div class="mfill" id="m1f"></div></div>
      </div>
      <div class="mcard">
        <div class="mrow"><span class="mttl" id="m2t">Mission 2</span><span id="m2s">0/1</span></div>
        <div class="mbar"><div class="mfill" id="m2f"></div></div>
      </div>
      <div class="mcard">
        <div class="mrow"><span class="mttl" id="m3t">Mission 3</span><span id="m3s">0/1</span></div>
        <div class="mbar"><div class="mfill" id="m3f"></div></div>
      </div>
    </div>

    <span class="pill" id="coach">Tip: ‡πÑ‡∏õ‡∏ó‡∏µ‡πà Shower ‡∏Å‡πà‡∏≠‡∏ô</span>
  </div>

  <div id="game">
    <canvas id="cv" width="860" height="580"></canvas>
    <div id="joy"><div id="nub"></div></div>

    <!-- Practice + mini-quest overlay -->
    <div id="overlay">
      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:flex-start; gap:10px; flex-wrap:wrap;">
          <div>
            <div class="h2" id="ovTitle">Practice Mode</div>
            <div class="muted" id="ovDesc">‡∏ù‡∏∂‡∏Å 15 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ: ‡πÄ‡∏î‡∏¥‡∏ô + ‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠</div>
          </div>
          <button id="ovBtn">‡πÄ‡∏£‡∏¥‡πà‡∏°</button>
        </div>
        <div style="margin-top:10px;">
          <div class="big" id="ovBig">15</div>
          <div class="muted" id="ovHint" style="margin-top:6px;">
            ‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏ù‡∏∂‡∏Å: ‡πÑ‡∏õ Shower ‚Üí Water / ‡πÑ‡∏õ Soap Rack ‚Üí Soap / ‡πÑ‡∏õ UV Mirror ‚Üí Scan 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á
          </div>
        </div>
      </div>
    </div>

    <!-- Result -->
    <div id="result">
      <div class="card">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
          <div>
            <div class="h2">üèÅ End Summary ‚Äî Heatmap</div>
            <div class="muted" id="resSub">‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏≠‡∏≤‡∏ö‡∏ô‡πâ‡∏≥</div>
          </div>
          <div style="display:flex; gap:8px; flex-wrap:wrap;">
            <button id="playAgain">‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
            <button id="closeRes">‡∏õ‡∏¥‡∏î</button>
          </div>
        </div>

        <div id="grid2" style="margin-top:10px;">
          <div>
            <canvas id="sil" width="560" height="440"></canvas>
            <div class="muted" style="margin-top:8px;" id="mistakes">Top mistakes:</div>
          </div>
          <div>
            <div class="h2">üìä Score Breakdown</div>
            <div class="kpi" id="kpi"></div>
            <div class="h2" style="margin-top:12px;">üß† Sequence Grade</div>
            <div class="pill" id="seqGrade">‚Äî</div>
            <div class="h2" style="margin-top:12px;">üß™ Notes</div>
            <div class="muted" id="notes">‚Äî</div>
          </div>
        </div>
      </div>
    </div>

  </div>

  <div id="toolbar">
    <div class="tools" id="tools">
      <button data-tool="water">üíß Water</button>
      <button data-tool="soap">ü´ß Soap</button>
      <button data-tool="scrub">üßΩ Scrub</button>
      <button data-tool="rinse">üöø Rinse</button>
      <button data-tool="dry">üß∫ Dry</button>
      <button data-tool="scan">üî¶ UV Scan</button>
      <span class="pill">Diff:
        <select id="diffSel">
          <option value="easy">Easy</option>
          <option value="normal" selected>Normal</option>
          <option value="hard">Hard</option>
        </select>
      </span>
      <span class="pill">Seed:
        <input id="seedInp" value="20260219" style="width:120px; font-weight:900;" />
      </span>
    </div>
    <button id="actionBtn">‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ</button>
  </div>
</div>

<script>
(() => {
  // ---------- DOM ----------
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const modeLbl = document.getElementById('modeLbl');
  const phaseLbl = document.getElementById('phaseLbl');
  const timeLbl  = document.getElementById('timeLbl');
  const heatLbl  = document.getElementById('heatLbl');
  const bubLbl   = document.getElementById('bubLbl');
  const comboLbl = document.getElementById('comboLbl');
  const debLbl   = document.getElementById('debLbl');
  const heatFill = document.getElementById('heatFill');
  const bubFill  = document.getElementById('bubFill');
  const coach    = document.getElementById('coach');
  const toolsEl  = document.getElementById('tools');
  const actionBtn= document.getElementById('actionBtn');
  const diffSel  = document.getElementById('diffSel');
  const seedInp  = document.getElementById('seedInp');

  // Missions DOM
  const m1t=document.getElementById('m1t'), m1s=document.getElementById('m1s'), m1f=document.getElementById('m1f');
  const m2t=document.getElementById('m2t'), m2s=document.getElementById('m2s'), m2f=document.getElementById('m2f');
  const m3t=document.getElementById('m3t'), m3s=document.getElementById('m3s'), m3f=document.getElementById('m3f');

  // Overlay (Practice / mini-quest)
  const overlayEl = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovDesc  = document.getElementById('ovDesc');
  const ovBig   = document.getElementById('ovBig');
  const ovHint  = document.getElementById('ovHint');
  const ovBtn   = document.getElementById('ovBtn');

  // Result
  const resultEl = document.getElementById('result');
  const silCv    = document.getElementById('sil');
  const silCtx   = silCv.getContext('2d');
  const kpiEl    = document.getElementById('kpi');
  const mistakesEl = document.getElementById('mistakes');
  const seqGradeEl = document.getElementById('seqGrade');
  const notesEl  = document.getElementById('notes');
  const resSubEl = document.getElementById('resSub');
  const playAgainBtn = document.getElementById('playAgain');
  const closeResBtn  = document.getElementById('closeRes');

  const W = cv.width, H = cv.height;
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

  // ---------- Audio + Haptics (2) ----------
  let AC = null;
  function audioCtx(){
    if(AC) return AC;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if(!Ctx) return null;
    AC = new Ctx();
    return AC;
  }
  function beep(freq=420, dur=0.06, type='sine', gain=0.05){
    const ac = audioCtx();
    if(!ac) return;
    try{
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(ac.destination);
      o.start();
      o.stop(ac.currentTime + dur);
    }catch(e){}
  }
  function rumble(ms=30){
    try{ if(navigator.vibrate) navigator.vibrate(ms); }catch(e){}
  }

  // ---------- RNG ----------
  function xmur3(str){
    let h = 1779033703 ^ str.length;
    for(let i=0;i<str.length;i++){
      h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
      h = (h << 13) | (h >>> 19);
    }
    return function(){
      h = Math.imul(h ^ (h >>> 16), 2246822507);
      h = Math.imul(h ^ (h >>> 13), 3266489909);
      h ^= (h >>> 16);
      return h >>> 0;
    }
  }
  function sfc32(a,b,c,d){
    return function(){
      a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
      let t = (a + b) | 0;
      a = b ^ (b >>> 9);
      b = (c + (c << 3)) | 0;
      c = (c << 21) | (c >>> 11);
      d = (d + 1) | 0;
      t = (t + d) | 0;
      c = (c + t) | 0;
      return (t >>> 0) / 4294967296;
    }
  }
  function makeRng(seedStr){
    const seed = xmur3(seedStr);
    return sfc32(seed(), seed(), seed(), seed());
  }

  // ---------- Map ----------
  const TILE = 28;
  const COLS = Math.floor(W / TILE);
  const ROWS = Math.floor(H / TILE);

  function makeMap(){
    const g = Array.from({length:ROWS}, ()=> Array(COLS).fill(0));
    const wall = (x,y)=>{ if(x>=0&&y>=0&&x<COLS&&y<ROWS) g[y][x]=1; };

    for(let x=0;x<COLS;x++){ wall(x,0); wall(x,ROWS-1); }
    for(let y=0;y<ROWS;y++){ wall(0,y); wall(COLS-1,y); }

    for(let x=6;x<18;x++) wall(x,6);
    for(let y=10;y<18;y++) wall(6,y);
    for(let y=15;y<18;y++) for(let x=9;x<12;x++) wall(x,y);
    for(let y=3;y<5;y++) for(let x=20;x<24;x++) wall(x,y);

    g[ROWS-1][Math.floor(COLS/2)] = 0;
    return g;
  }
  let GRID = makeMap();

  function isBlocked(px,py,r){
    const minX = Math.floor((px-r)/TILE);
    const maxX = Math.floor((px+r)/TILE);
    const minY = Math.floor((py-r)/TILE);
    const maxY = Math.floor((py+r)/TILE);
    for(let ty=minY; ty<=maxY; ty++){
      for(let tx=minX; tx<=maxX; tx++){
        if(tx<0||ty<0||tx>=COLS||ty>=ROWS) return true;
        if(GRID[ty][tx]!==1) continue;
        const rx = tx*TILE, ry = ty*TILE;
        const cx = clamp(px, rx, rx+TILE);
        const cy = clamp(py, ry, ry+TILE);
        const dx = px-cx, dy = py-cy;
        if(dx*dx+dy*dy <= r*r) return true;
      }
    }
    return false;
  }

  // ---------- Stations ----------
  const ST = {
    shower: { id:'shower', x: 3*TILE, y: 3*TILE, r: 2.6*TILE, label:'üöø Shower' },
    soap:   { id:'soap',   x: 23*TILE, y: 4*TILE, r: 2.1*TILE, label:'ü´ß Soap Rack' },
    scan:   { id:'scan',   x: 23*TILE, y: 10*TILE, r: 2.1*TILE, label:'üî¶ UV Mirror' },
    towel:  { id:'towel',  x: 23*TILE, y: 16*TILE, r: 2.1*TILE, label:'üß∫ Towel' },
    basket: { id:'basket', x: 3*TILE,  y: 17*TILE, r: 2.2*TILE, label:'üëï Basket' },
  };
  function inZone(px,py, z){
    const dx=px-z.x, dy=py-z.y;
    return dx*dx+dy*dy <= z.r*z.r;
  }
  function inCircle(px,py,cx,cy,r){
    const dx=px-cx, dy=py-cy;
    return dx*dx+dy*dy <= r*r;
  }

  // ---------- A) Wet floor around shower ----------
  const WET_FLOOR = { x: ST.shower.x, y: ST.shower.y, r: ST.shower.r*1.55 };

  // ---------- Player ----------
  const P = { x: 5*TILE, y: 16*TILE, r: 10, vx:0, vy:0 };

  // ---------- Difficulty ----------
  const DIFF = {
    easy:   { time: 90, bubble: 120, heatRise: 0.45, reveal: 0.80, holdMul: 0.75, bossChance: 0.45, scanLeft: 3 },
    normal: { time: 80, bubble: 100, heatRise: 0.60, reveal: 0.55, holdMul: 1.00, bossChance: 0.70, scanLeft: 2 },
    hard:   { time: 70, bubble: 90,  heatRise: 0.78, reveal: 0.35, holdMul: 1.18, bossChance: 0.92, scanLeft: 2 },
  };

  // ---------- Tools ----------
  let tool = 'water';
  let holding = false;
  let holdMs = 0;

  // ---------- Modes / Phases (3: Practice 15s) ----------
  const MODE = { PRACTICE:0, RUN:1, DONE:2 };
  let mode = MODE.PRACTICE;

  const PH = { PREP:0, WET:1, SOAP:2, SCRUB:3, RINSE:4, DRY:5, DRESS:6, DONE:7 };
  let phase = PH.PREP;
  let prepMs = 1800;

  // Practice state
  let pracLeft = 15.0;           // seconds
  let pracGoals = { shower:false, soap:false, scan:false };

  // ---------- Resources ----------
  let heat=0, bubble=100, tLeft=80;
  let combo=1.0;
  let scanLeft = 2;

  // ---------- Debuff system (1) ----------
  // debuff types: NONE, BUBBLE_LEAK, HEAT_RISE, SLIP_PLUS
  let debuff = { type:'NONE', until:0 };
  function debuffSet(type, ms){
    const now = performance.now();
    debuff.type = type;
    debuff.until = now + ms;
    debLbl.textContent = type==='NONE' ? '‚Äî' : type;
  }
  function debuffActive(){
    const now = performance.now();
    if(debuff.type==='NONE') return false;
    if(now > debuff.until){ debuffSet('NONE',0); return false; }
    return true;
  }

  // ---------- Stats ----------
  const STATS = {
    cleanScore:0,
    residuePenalty:0,
    fungusRisk:0,
    seqOk:0,
    seqBad:0,
    wrongOrder:0,
    regrowCount:0,
    spreadCount:0,
    bossKilled:0,
    scansUsed:0,
    slips:0,
    miniQuestFail:0,
    miniQuestPass:0,
  };

  // ---------- Spots pool ----------
  const SPOT_POOL = [
    { id:'behindEar',  name:'‡∏´‡∏•‡∏±‡∏á‡∏´‡∏π',        ox:-10, oy:-18, hold:1200, weight:1.3, zone:'head' },
    { id:'neckBack',   name:'‡∏´‡∏•‡∏±‡∏á‡∏Ñ‡∏≠',        ox: 10, oy:-16, hold:1400, weight:1.4, zone:'head' },
    { id:'armpit',     name:'‡∏£‡∏±‡∏Å‡πÅ‡∏£‡πâ',        ox: 16, oy:  0, hold:1700, weight:1.6, zone:'arms' },
    { id:'elbowFold',  name:'‡∏Ç‡πâ‡∏≠‡∏û‡∏±‡∏ö‡πÅ‡∏Ç‡∏ô',     ox:-18, oy:  2, hold:1500, weight:1.5, zone:'arms' },
    { id:'belly',      name:'‡∏£‡∏≠‡∏ö‡∏™‡∏∞‡∏î‡∏∑‡∏≠',      ox:  0, oy:  6, hold:1350, weight:1.3, zone:'torso' },
    { id:'backKnee',   name:'‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏Ç‡πà‡∏≤',      ox: -8, oy: 18, hold:1500, weight:1.5, zone:'legs' },
    { id:'toes',       name:'‡∏ã‡∏≠‡∏Å‡∏ô‡∏¥‡πâ‡∏ß‡πÄ‡∏ó‡πâ‡∏≤',   ox: 10, oy: 22, hold:1800, weight:1.7, zone:'legs' },
  ];

  let rng = makeRng(seedInp.value.trim() || '20260219');
  let spots = [];
  let boss = null;

  // ---------- Mini-Quest items (1) ----------
  // items spawn on map; player can "pick" by holding near.
  // correct order per phase: SOAP phase expects SOAP item; DRY expects TOWEL; optional: SHAMPOO gives bonus (but wrong time debuff)
  const ITEM_TYPES = {
    SHAMPOO:{ id:'shampoo', icon:'üß¥', label:'Shampoo', bonus:10 },
    SOAP:   { id:'soap',    icon:'ü´ß', label:'Soap', bonus:8  },
    TOWEL:  { id:'towel',   icon:'üß∫', label:'Towel', bonus:8  },
  };
  let items = []; // {typeId,x,y,r,picked:boolean}
  function spawnItems(){
    // deterministic positions (seed-based)
    const pickPos = (minTx,maxTx,minTy,maxTy) => {
      for(let k=0;k<50;k++){
        const tx = Math.floor(minTx + rng()*(maxTx-minTx));
        const ty = Math.floor(minTy + rng()*(maxTy-minTy));
        const x = tx*TILE + TILE/2;
        const y = ty*TILE + TILE/2;
        if(!isBlocked(x,y,10)) return {x,y};
      }
      return {x: 12*TILE, y: 12*TILE};
    };

    items = [];
    const p1 = pickPos(10,18, 9,13);
    const p2 = pickPos(15,24, 12,18);
    const p3 = pickPos( 2, 8, 8,14);

    // one of each (shampoo/soap/towel)
    items.push({ typeId:'shampoo', ...p1, r:14, picked:false });
    items.push({ typeId:'soap',    ...p2, r:14, picked:false });
    items.push({ typeId:'towel',   ...p3, r:14, picked:false });
  }
  function itemAtPlayer(){
    for(const it of items){
      if(it.picked) continue;
      if(inCircle(P.x,P.y, it.x,it.y, it.r+18)) return it;
    }
    return null;
  }
  function expectedItemForPhase(){
    if(phase===PH.SOAP) return 'soap';
    if(phase===PH.DRY)  return 'towel';
    // shampoo: bonus-only; ‚Äúwrong time‚Äù causes debuff
    return null;
  }
  function pickItem(it){
    it.picked = true;
    const exp = expectedItemForPhase();
    if(exp && it.typeId===exp){
      STATS.miniQuestPass++;
      // reward: bubble + small heat drop
      bubble = clamp(bubble + 10, 0, 140);
      heat   = clamp(heat - 6, 0, 100);
      beep(660, 0.07, 'triangle', 0.06); rumble(20);
      coachSay(`‡πÄ‡∏Å‡πá‡∏ö‡∏ñ‡∏π‡∏Å: ${ITEM_TYPES_LABEL(it.typeId)} ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ Phase ‡∏ô‡∏µ‡πâ‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏Ç‡∏∂‡πâ‡∏ô`);
    } else if(!exp && it.typeId==='shampoo'){
      STATS.miniQuestPass++;
      // reward: bonus score later via stats only; in-run effect small
      bubble = clamp(bubble + 6, 0, 140);
      beep(720, 0.06, 'sine', 0.05);
      coachSay('Shampoo bonus! ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÄ‡∏Å‡πá‡∏ö‡πÑ‡∏î‡πâ‡∏à‡∏∞‡∏ä‡πà‡∏ß‡∏¢‡∏•‡∏î‡∏Ñ‡∏£‡∏≤‡∏ö‡∏°‡∏±‡∏ô‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢ (‡πÑ‡∏°‡πà‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö)');
    } else {
      STATS.miniQuestFail++;
      // debuff depends on mismatch
      const roll = rng();
      const type = roll<0.34 ? 'BUBBLE_LEAK' : roll<0.67 ? 'HEAT_RISE' : 'SLIP_PLUS';
      debuffSet(type, 6500);
      beep(220, 0.10, 'sawtooth', 0.04); rumble(55);
      coachSay(`‡∏´‡∏¢‡∏¥‡∏ö‡∏ú‡∏¥‡∏î‡πÄ‡∏ß‡∏•‡∏≤ ‚Üí Debuff (${type}) ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÉ‡∏ä‡πâ‡∏≠‡∏∏‡∏õ‡∏Å‡∏£‡∏ì‡πå‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Ç‡∏±‡πâ‡∏ô`);
    }
  }
  function ITEM_TYPES_LABEL(id){
    if(id==='shampoo') return 'Shampoo';
    if(id==='soap') return 'Soap';
    if(id==='towel') return 'Towel';
    return id;
  }

  // ---------- B) Missions ----------
  let missions = [];
  function makeMissions(){
    const r = rng;
    const pickSpot = () => spots[Math.floor(r()*spots.length)];
    const s1 = pickSpot();
    let s2 = pickSpot(); if(s2.id===s1.id) s2 = spots[(spots.indexOf(s1)+1)%spots.length];

    missions = [
      {
        id:'m1',
        title:`‡∏•‡πà‡∏≤‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö: ${s1.name} + ${s2.name}`,
        type:'cleanSpecific',
        targets:[s1.id, s2.id],
        done:0, need:2,
        bonus:20,
      },
      {
        id:'m2',
        title:`‡∏Ñ‡∏∏‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡πâ‡∏≠‡∏ô: Heat ‚â§ ${diffSel.value==='hard'?60:65}`,
        type:'keepHeat',
        threshold: diffSel.value==='hard'?60:65,
        done:0, need:1,
        bonus:15,
      },
      {
        id:'m3',
        title:`‡∏•‡πâ‡∏≤‡∏á‡∏ü‡∏≠‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏ô‡∏µ‡∏¢‡∏ô: Residue ‚â§ ${diffSel.value==='hard'?6:8}`,
        type:'limitResidue',
        limit: diffSel.value==='hard'?6:8,
        done:0, need:1,
        bonus:15,
      },
    ];
    renderMissions();
  }
  function renderMissions(){
    const m1=missions[0], m2=missions[1], m3=missions[2];
    m1t.textContent=m1.title; m2t.textContent=m2.title; m3t.textContent=m3.title;
    updateMissionUI();
  }
  function updateMissionUI(){
    const ms = missions;
    if(!ms.length) return;
    const set = (m, sEl, fEl) => {
      sEl.textContent = `${m.done}/${m.need}`;
      fEl.style.width = `${Math.round((m.done/m.need)*100)}%`;
    };
    set(ms[0], m1s, m1f);
    set(ms[1], m2s, m2f);
    set(ms[2], m3s, m3f);
  }
  function missionAddDone(id, inc=1){
    const m = missions.find(x=>x.id===id);
    if(!m) return;
    m.done = clamp(m.done + inc, 0, m.need);
    updateMissionUI();
  }
  function missionFinalize(){
    const m2 = missions.find(m=>m.id==='m2');
    const m3 = missions.find(m=>m.id==='m3');
    if(m2 && heat <= m2.threshold) m2.done = m2.need;
    if(m3 && STATS.residuePenalty <= m3.limit) m3.done = m3.need;
    updateMissionUI();
  }
  function missionBonusTotal(){
    let b=0;
    for(const m of missions){ if(m.done>=m.need) b += m.bonus; }
    return b;
  }

  // ---------- C) AI Coach ----------
  const COACH = { lastAt:-9999, cooldownMs:1400, lastMsg:'' };
  function coachSay(msg){
    const now = performance.now();
    if(now-COACH.lastAt < COACH.cooldownMs && msg===COACH.lastMsg) return;
    COACH.lastAt = now; COACH.lastMsg = msg;
    coach.textContent = 'Tip: ' + msg;
  }
  function coachCheck(){
    if(mode===MODE.PRACTICE){
      if(!pracGoals.shower) coachSay('Practice: ‡πÑ‡∏õ Shower ‡πÅ‡∏•‡πâ‡∏ß Water ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏•‡πâ‡∏≤‡∏á‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö');
      else if(!pracGoals.soap) coachSay('Practice: ‡πÑ‡∏õ Soap Rack ‡πÅ‡∏•‡πâ‡∏ß Soap ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ü‡∏≠‡∏Å‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡∏∂‡∏á‡∏ñ‡∏π');
      else if(!pracGoals.scan) coachSay('Practice: ‡πÑ‡∏õ UV Mirror ‡πÅ‡∏•‡πâ‡∏ß Scan 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÄ‡∏´‡πá‡∏ô‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö');
      else coachSay('Practice: ‡πÄ‡∏Å‡πà‡∏á‡πÅ‡∏•‡πâ‡∏ß! ‡∏£‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏î‡πà‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á');
      return;
    }
    if(phase===PH.WET){
      if(!inZone(P.x,P.y, ST.shower)) coachSay('Wet ‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡πÉ‡∏ô Shower ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÄ‡∏õ‡∏µ‡∏¢‡∏Å‡πÑ‡∏°‡πà‡∏ó‡∏±‡πà‡∏ß ‡∏ü‡∏≠‡∏Å‡πÑ‡∏°‡πà‡∏ï‡∏¥‡∏î');
      else if(tool!=='water') coachSay('‡∏≠‡∏¢‡∏π‡πà Shower ‡πÅ‡∏•‡πâ‡∏ß ‡πÉ‡∏ä‡πâ Water ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏•‡∏î Heat ‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö');
    }
    if(phase===PH.SOAP){
      if(!inZone(P.x,P.y, ST.soap)) coachSay('‡πÑ‡∏õ Soap Rack ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ü‡∏≠‡∏Å‡πÅ‡∏£‡∏á‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î Bubble');
      if(tool!=='soap') coachSay('Phase Soap: ‡πÉ‡∏ä‡πâ Soap ‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡∏π ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏Å‡∏±‡∏ô ‚Äú‡∏õ‡∏•‡∏≠‡∏°‡∏™‡∏∞‡∏≠‡∏≤‡∏î‚Äù');
    }
    if(phase===PH.SCRUB){
      const soaped = spots.filter(s=>s.state==='soaped');
      if(!soaped.length) coachSay('‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà Soap ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ï‡πâ‡∏≠‡∏á‡∏ü‡∏≠‡∏Å‡∏Å‡πà‡∏≠‡∏ô‡∏ñ‡∏π');
      if(tool!=='scrub') coachSay('Phase Scrub: ‡πÉ‡∏ä‡πâ Scrub ‡πÅ‡∏•‡∏∞‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏ß‡∏•‡∏≤');
      if(bubble<18) coachSay('Bubble ‡∏ï‡πà‡∏≥ ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ñ‡∏π‡∏ä‡πâ‡∏≤‡∏•‡∏á ‡∏•‡∏≠‡∏á Shower ‡∏•‡∏î Heat ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡∏ï‡πà‡∏≠');
    }
    if(phase===PH.RINSE){
      if(!inZone(P.x,P.y, ST.shower)) coachSay('Rinse ‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏•‡∏±‡∏ö Shower ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÑ‡∏°‡πà‡∏•‡πâ‡∏≤‡∏á‡∏ü‡∏≠‡∏á = residue ‡∏ï‡∏¥‡∏î‡∏•‡∏ö');
    }
    if(phase===PH.DRY){
      if(!inZone(P.x,P.y, ST.towel)) coachSay('Dry ‡∏ó‡∏µ‡πà Towel ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ä‡∏∑‡πâ‡∏ô = fungus risk ‡πÄ‡∏û‡∏¥‡πà‡∏°');
    }
  }

  // ---------- Spots ----------
  function spawnSpots(){
    const pool = [...SPOT_POOL];
    const pick = (fn)=>{
      const candidates = pool.filter(fn);
      if(!candidates.length) return null;
      const idx = Math.floor(rng()*candidates.length);
      const s = candidates[idx];
      pool.splice(pool.indexOf(s),1);
      return s;
    };
    const out = [];
    const sLeg = pick(s=>s.zone==='legs'); if(sLeg) out.push(sLeg);
    const sHead = pick(s=>s.zone==='head'); if(sHead) out.push(sHead);
    const sArms = pick(s=>s.zone==='arms'); if(sArms) out.push(sArms);
    while(out.length<4 && pool.length){
      const idx = Math.floor(rng()*pool.length);
      out.push(pool.splice(idx,1)[0]);
    }
    spots = out.map(s=>({
      ...s,
      state:'hidden',
      prog:0,
      shinyNotClean:false,
      wetUnlocked:false,
      lastStep:'none',
      mistakes:0,
      cleaned:false
    }));
  }

  // ---------- Sequence ----------
  function seqStepOk(prev, next){
    const order = ['none','wet','soap','scrub','rinse','dry','dress'];
    return order.indexOf(next) === order.indexOf(prev)+1;
  }
  function applySeq(spot, step){
    if(mode===MODE.PRACTICE){
      // practice: no harsh punish, still teaches order gently
      if(seqStepOk(spot.lastStep, step)) spot.lastStep = step;
      return true;
    }
    if(seqStepOk(spot.lastStep, step)){
      spot.lastStep = step;
      STATS.seqOk++;
      combo = clamp(combo + 0.03, 1.0, 2.0);
      return true;
    } else {
      STATS.seqBad++;
      STATS.wrongOrder++;
      combo = clamp(combo - 0.06, 1.0, 2.0);

      const roll = rng();
      if(roll < 0.55){
        STATS.regrowCount++;
        spot.mistakes++;
        if(spot.state==='soaped' || spot.state==='scrubbing') spot.state='revealed';
        if(spot.state==='cleanCandidate') spot.state='soaped';
        spot.prog=0;
        heat = clamp(heat + 3, 0, 100);
        beep(240,0.06,'square',0.03); rumble(20);
        coachSay(`‡∏ú‡∏¥‡∏î‡∏•‡∏≥‡∏î‡∏±‡∏ö ‚Üí ‡∏Ñ‡∏£‡∏≤‡∏ö‡∏ü‡∏∑‡πâ‡∏ô‡∏ï‡∏±‡∏ß (${spot.name}) ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏Ç‡πâ‡∏≤‡∏°‡∏Ç‡∏±‡πâ‡∏ô`);
      } else {
        STATS.spreadCount++;
        heat = clamp(heat + 4, 0, 100);
        const hidden = spots.find(s=>s.state==='hidden');
        if(hidden){ hidden.state='revealed'; hidden.wetUnlocked=true; }
        STATS.residuePenalty += 2;
        beep(200,0.08,'sawtooth',0.03); rumble(25);
        coachSay('‡∏ú‡∏¥‡∏î‡∏•‡∏≥‡∏î‡∏±‡∏ö ‚Üí ‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡∏Å‡∏£‡∏∞‡∏à‡∏≤‡∏¢ ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡πÑ‡∏õ‡∏Ç‡∏±‡πâ‡∏ô‡∏ñ‡∏±‡∏î‡πÑ‡∏õ‡∏Å‡πà‡∏≠‡∏ô‡∏•‡πâ‡∏≤‡∏á‡∏Ñ‡∏£‡∏ö');
      }
      return false;
    }
  }

  // ---------- Boss ----------
  function allCleanCandidate(){
    return spots.every(s=> s.state==='cleanCandidate' || s.state==='rinsed' || s.state==='dried' || s.state==='done');
  }
  function allRinsed(){
    return spots.every(s=> s.state==='rinsed' || s.state==='dried' || s.state==='done');
  }
  function maybeSpawnBoss(){
    if(mode!==MODE.RUN) return;
    if(boss) return;
    const d = DIFF[diffSel.value] || DIFF.normal;
    const trigger = (heat > 72) || (STATS.wrongOrder >= 2) || (tLeft < d.time*0.55 && !allCleanCandidate());
    if(!trigger) return;
    if(rng() > d.bossChance) return;

    let s = spots.find(x=>x.state==='revealed' || x.state==='soaped') || spots[0];
    if(s.state==='hidden'){ s.state='revealed'; s.wetUnlocked=true; }
    const type = (rng()<0.5) ? 'stink' : 'oil';

    boss = {
      type,
      spotId: s.id,
      hp: type==='stink' ? 100 : 120,
      armor: type==='oil' ? 3 : 0,
      pulseT: 0,
      spreadT: 0,
    };
    beep(140,0.10,'sawtooth',0.05); rumble(70);
    coachSay(type==='stink'
      ? '‚ö†Ô∏è Stink Monster: ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏•‡πâ‡∏≤‡∏á‡∏ñ‡∏π‡∏Å‡∏•‡∏≥‡∏î‡∏±‡∏ö Heat ‡∏à‡∏∞‡∏û‡∏∏‡πà‡∏á'
      : '‚ö†Ô∏è Oil Boss: ‡∏ï‡πâ‡∏≠‡∏á Wet ‡∏Å‡πà‡∏≠‡∏ô Scrub ‡πÑ‡∏°‡πà‡∏á‡∏±‡πâ‡∏ô‡πÑ‡∏°‡πà‡∏´‡∏•‡∏∏‡∏î');
  }
  function updateBoss(dt){
    if(!boss) return;
    boss.pulseT += dt;
    boss.spreadT += dt;

    if(boss.pulseT > 1500){
      boss.pulseT = 0;
      heat = clamp(heat + (boss.type==='stink'?4:3), 0, 100);
      STATS.residuePenalty += (boss.type==='stink'?2:1);
      // (2) haptics/sfx pulse
      beep(boss.type==='stink'?170:190, 0.05, 'square', 0.04);
      rumble(25);
    }

    if(boss.spreadT > (boss.type==='stink'?2400:2800)){
      boss.spreadT = 0;
      const hidden = spots.find(s=>s.state==='hidden');
      if(hidden){
        hidden.state='revealed'; hidden.wetUnlocked=true;
        STATS.spreadCount++;
      } else {
        const c = spots.find(s=>s.state==='cleanCandidate' || s.state==='rinsed');
        if(c){
          c.state='soaped'; c.prog=0; c.shinyNotClean=true;
          STATS.regrowCount++;
        }
      }
    }
  }
  function damageBoss(amount){
    if(!boss) return;
    boss.hp -= amount;
    if(boss.hp<=0){
      STATS.bossKilled++;
      bubble = clamp(bubble + 18, 0, 140);
      heat = clamp(heat - 14, 0, 100);
      boss = null;
      beep(820,0.08,'triangle',0.07); rumble(35);
      coachSay('‚úÖ Boss ‡∏ñ‡∏π‡∏Å‡∏ä‡∏≥‡∏£‡∏∞! ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ó‡∏≥‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Ñ‡∏£‡∏ö ‡∏Ñ‡∏£‡∏≤‡∏ö‡∏™‡∏∞‡∏™‡∏°‡πÑ‡∏°‡πà‡∏ó‡∏±‡∏ô');
    }
  }

  // ---------- Practice overlay (3) ----------
  function showOverlay(title, desc, big, hint, btnText){
    ovTitle.textContent = title;
    ovDesc.textContent  = desc;
    ovBig.textContent   = big;
    ovHint.textContent  = hint;
    ovBtn.textContent   = btnText || '‡πÄ‡∏£‡∏¥‡πà‡∏°';
    overlayEl.style.display = 'block';
  }
  function hideOverlay(){ overlayEl.style.display = 'none'; }
  ovBtn.addEventListener('click', async ()=>{
    // ensure audio can play after user gesture
    const ac = audioCtx();
    if(ac && ac.state==='suspended') { try{ await ac.resume(); }catch(e){} }
    hideOverlay();
  });

  // ---------- Tools ----------
  function tipForTool(){
    if(phase===PH.DONE) return;
    if(tool==='water') coachSay('Water ‡πÉ‡∏ô Shower: ‡∏•‡∏î Heat ‡πÅ‡∏•‡∏∞‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö');
    else if(tool==='soap') coachSay('Soap ‡∏ó‡∏µ‡πà Soap Rack: ‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î Bubble ‡πÅ‡∏•‡∏∞‡∏ü‡∏≠‡∏Å‡πÅ‡∏£‡∏á');
    else if(tool==='scrub') coachSay('Scrub: ‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏à‡∏£‡∏¥‡∏á');
    else if(tool==='rinse') coachSay('Rinse ‡πÉ‡∏ô Shower: ‡∏Å‡∏±‡∏ô residue ‡∏ï‡∏¥‡∏î‡∏•‡∏ö');
    else if(tool==='dry') coachSay('Dry ‡∏ó‡∏µ‡πà Towel: ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏∑‡πâ‡∏ô ‡∏•‡∏î‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡∏£‡∏≤');
    else if(tool==='scan') coachSay('UV Scan ‡∏ó‡∏µ‡πà Mirror: ‡πÄ‡∏´‡πá‡∏ô‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö (‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á)');
  }
  function setTool(t){
    tool = t;
    [...toolsEl.querySelectorAll('button[data-tool]')].forEach(x=>x.classList.toggle('sel', x.dataset.tool===tool));
    tipForTool();
  }

  // ---------- Input ----------
  const keys = {};
  addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
  addEventListener('keyup',   e => { keys[e.key.toLowerCase()] = false; });

  function setHolding(v){ holding=v; if(!v) holdMs=0; }
  actionBtn.addEventListener('pointerdown', e=>{ actionBtn.setPointerCapture(e.pointerId); setHolding(true); });
  actionBtn.addEventListener('pointerup',   ()=> setHolding(false));
  actionBtn.addEventListener('pointercancel',()=> setHolding(false));
  cv.addEventListener('pointerdown', e=>{ cv.setPointerCapture(e.pointerId); setHolding(true); });
  cv.addEventListener('pointerup',   ()=> setHolding(false));
  cv.addEventListener('pointercancel',()=> setHolding(false));

  // Joystick
  const joy = document.getElementById('joy');
  const nub = document.getElementById('nub');
  let joyOn=false, joyId=null, joyCx=0, joyCy=0, joyDx=0, joyDy=0;
  joy.addEventListener('pointerdown', e=>{
    joy.setPointerCapture(e.pointerId);
    joyOn=true; joyId=e.pointerId;
    const r = joy.getBoundingClientRect();
    joyCx = r.left + r.width/2;
    joyCy = r.top + r.height/2;
    updateJoy(e.clientX, e.clientY);
  });
  joy.addEventListener('pointermove', e=>{
    if(!joyOn || e.pointerId!==joyId) return;
    updateJoy(e.clientX, e.clientY);
  });
  joy.addEventListener('pointerup', e=>{
    if(e.pointerId!==joyId) return;
    joyOn=false; joyId=null; joyDx=joyDy=0;
    nub.style.left='48px'; nub.style.top='48px';
  });
  function updateJoy(x,y){
    const dx=x-joyCx, dy=y-joyCy;
    const m=Math.sqrt(dx*dx+dy*dy);
    const max=44;
    const nx=(m>max? dx/m*max : dx);
    const ny=(m>max? dy/m*max : dy);
    joyDx=nx/max; joyDy=ny/max;
    nub.style.left=(48+nx)+'px';
    nub.style.top =(48+ny)+'px';
  }

  // ---------- Restart ----------
  diffSel.addEventListener('change', ()=> restart());
  seedInp.addEventListener('change', ()=> restart());
  playAgainBtn.addEventListener('click', ()=> restart());
  closeResBtn.addEventListener('click', ()=> { resultEl.style.display='none'; });

  // ---------- Core state ----------
  function setMode(m){
    mode = m;
    modeLbl.textContent = (mode===MODE.PRACTICE?'PRACTICE':mode===MODE.RUN?'RUN':'DONE');
  }
  function setPhase(p){
    phase = p;
    phaseLbl.textContent = Object.keys(PH).find(k=>PH[k]===phase);
    if(mode===MODE.RUN){
      if(phase===PH.WET) coachSay('Phase Wet: ‡πÑ‡∏õ Shower ‡πÅ‡∏•‡πâ‡∏ß Water ‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö (‡∏£‡∏∞‡∏ß‡∏±‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏•‡∏∑‡πà‡∏ô)');
      if(phase===PH.SOAP) coachSay('Phase Soap: ‡πÑ‡∏õ Soap Rack ‡πÅ‡∏•‡πâ‡∏ß‡∏ü‡∏≠‡∏Å‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö (‡∏ñ‡πâ‡∏≤‡∏´‡∏¢‡∏¥‡∏ö Soap item ‡∏à‡∏∞‡∏Ñ‡∏∏‡πâ‡∏°)');
      if(phase===PH.SCRUB) coachSay('Phase Scrub: ‡∏ñ‡∏π‡∏Ñ‡πâ‡∏≤‡∏á‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡πÄ‡∏ß‡∏•‡∏≤ (‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö‡∏ô‡∏≤‡∏ô‡∏Å‡∏ß‡πà‡∏≤)');
      if(phase===PH.RINSE) coachSay('Phase Rinse: ‡∏Å‡∏•‡∏±‡∏ö Shower ‡∏•‡πâ‡∏≤‡∏á‡∏ü‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à residue');
      if(phase===PH.DRY) coachSay('Phase Dry: ‡πÑ‡∏õ Towel ‡πÄ‡∏ä‡πá‡∏î‡πÉ‡∏´‡πâ‡πÅ‡∏´‡πâ‡∏á (‡∏´‡∏¢‡∏¥‡∏ö Towel item ‡∏à‡∏∞‡∏Ñ‡∏∏‡πâ‡∏°)');
      if(phase===PH.DRESS) coachSay('Phase Dress: ‡πÑ‡∏õ Basket ‡πÉ‡∏™‡πà‡πÄ‡∏™‡∏∑‡πâ‡∏≠‡∏ú‡πâ‡∏≤‡∏™‡∏∞‡∏≠‡∏≤‡∏î');
    }
  }

  // ---------- Init / Restart ----------
  function restart(){
    GRID = makeMap();
    rng = makeRng(seedInp.value.trim() || '20260219');
    const d = DIFF[diffSel.value] || DIFF.normal;

    heat=0; bubble=d.bubble; tLeft=d.time; combo=1.0;
    scanLeft = d.scanLeft;
    prepMs=1400; boss=null;
    debuffSet('NONE',0);

    for(const k of Object.keys(STATS)) STATS[k]=0;

    spawnSpots();
    spawnItems();   // (1)
    makeMissions();

    P.x = 5*TILE; P.y = 16*TILE;
    P.vx=0; P.vy=0;

    resultEl.style.display='none';
    setTool('water');

    // Practice reset (3)
    pracLeft = 15.0;
    pracGoals = { shower:false, soap:false, scan:false };
    setMode(MODE.PRACTICE);
    setPhase(PH.PREP);

    showOverlay(
      'Practice Mode (15s)',
      '‡∏ù‡∏∂‡∏Å‡∏Å‡πà‡∏≠‡∏ô‡∏•‡∏á‡∏î‡πà‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á: ‡πÄ‡∏î‡∏¥‡∏ô + ‡∏Å‡∏î‡∏Ñ‡πâ‡∏≤‡∏á‡πÉ‡∏ä‡πâ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠',
      '15',
      '‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏ù‡∏∂‡∏Å: ‡πÑ‡∏õ Shower ‚Üí Water / ‡πÑ‡∏õ Soap Rack ‚Üí Soap / ‡πÑ‡∏õ UV Mirror ‚Üí Scan 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á',
      '‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ù‡∏∂‡∏Å'
    );

    coachSay('Practice: ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å Shower ‡∏Å‡πà‡∏≠‡∏ô');
  }

  // ---------- Loop ----------
  let last = performance.now();
  restart();
  requestAnimationFrame(frame);

  function frame(now){
    const dt = now-last; last=now;
    update(dt);
    render();
    requestAnimationFrame(frame);
  }

  // ---------- Update ----------
  function update(dt){
    if(phase===PH.DONE) return;

    const d = DIFF[diffSel.value] || DIFF.normal;

    // Practice countdown (3)
    if(mode===MODE.PRACTICE){
      // overlay big timer if visible
      if(overlayEl.style.display==='block'){
        // just display current time, do not tick until start pressed
      } else {
        pracLeft -= dt/1000;
        if(pracLeft < 0) pracLeft = 0;
        ovBig.textContent = String(Math.ceil(pracLeft));
        // end practice early if all goals done
        if((pracGoals.shower && pracGoals.soap && pracGoals.scan) || pracLeft<=0){
          // transition to RUN
          setMode(MODE.RUN);
          setPhase(PH.WET);
          coachSay('‡πÄ‡∏Ç‡πâ‡∏≤‡πÄ‡∏Å‡∏°‡∏à‡∏£‡∏¥‡∏á! ‡πÑ‡∏õ Shower ‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏£‡∏¥‡πà‡∏° Wet');
          beep(520,0.08,'triangle',0.05);
          // no overlay now
          overlayEl.style.display='none';
        }
      }
    }

    // prep timer only at beginning of RUN (keep it light)
    if(mode===MODE.RUN && phase===PH.PREP){
      prepMs -= dt;
      if(prepMs<=0) setPhase(PH.WET);
    }

    // timer / heat for RUN only
    if(mode===MODE.RUN && phase!==PH.PREP){
      tLeft -= dt/1000; if(tLeft<0) tLeft=0;

      // base heat rise + debuff modifier
      let heatRise = d.heatRise;
      if(debuffActive() && debuff.type==='HEAT_RISE') heatRise *= 1.45;
      heat += (dt/1000) * heatRise;
      if(!holding) heat += (dt/1000)*0.10;
    }

    // wet floor slip (A) + debuff slip
    const onWetFloor = inCircle(P.x,P.y, WET_FLOOR.x, WET_FLOOR.y, WET_FLOOR.r);
    const slipPlus = (debuffActive() && debuff.type==='SLIP_PLUS') ? 1 : 0;

    // movement input
    let mx=0,my=0;
    if(keys['arrowleft']||keys['a']) mx-=1;
    if(keys['arrowright']||keys['d']) mx+=1;
    if(keys['arrowup']||keys['w']) my-=1;
    if(keys['arrowdown']||keys['s']) my+=1;
    mx += joyDx; my += joyDy;
    const m = Math.hypot(mx,my);
    if(m>1e-3){ mx/=Math.max(1,m); my/=Math.max(1,m); }

    // velocity with friction
    const accel = 900;
    const fricBase = onWetFloor ? 5.5 : 10.5;
    const fric = slipPlus ? Math.max(3.8, fricBase-2.0) : fricBase;

    P.vx += mx * accel * (dt/1000);
    P.vy += my * accel * (dt/1000);
    P.vx *= Math.exp(-fric*(dt/1000));
    P.vy *= Math.exp(-fric*(dt/1000));

    const vmax = onWetFloor ? 230 : 200;
    const sp = Math.hypot(P.vx,P.vy);
    if(sp>vmax){
      P.vx = P.vx/sp*vmax;
      P.vy = P.vy/sp*vmax;
    }

    // move collision (axis separate)
    let nx = P.x + P.vx*(dt/1000);
    let ny = P.y;
    if(!isBlocked(nx,ny,P.r)) P.x = nx;
    else {
      P.vx *= -0.22;
      heat = clamp(heat + 0.35,0,100);
      if(onWetFloor){
        STATS.slips++;
        // (2) haptic/sfx for slip
        beep(160,0.05,'square',0.03);
        rumble(18);
      }
    }
    nx = P.x;
    ny = P.y + P.vy*(dt/1000);
    if(!isBlocked(nx,ny,P.r)) P.y = ny;
    else {
      P.vy *= -0.22;
      heat = clamp(heat + 0.35,0,100);
      if(onWetFloor){
        STATS.slips++;
        beep(160,0.05,'square',0.03);
        rumble(18);
      }
    }

    // clamp
    heat = clamp(heat, 0, 100);
    bubble = clamp(bubble, 0, 140);

    // debuff bubble leak (1)
    if(mode===MODE.RUN && debuffActive() && debuff.type==='BUBBLE_LEAK'){
      bubble = clamp(bubble - (dt/1000)*6.5, 0, 140);
    }

    // boss update
    updateBoss(dt);

    // reveal trickle in RUN only
    if(mode===MODE.RUN && phase>=PH.WET){
      for(const s of spots){
        if(s.state==='hidden'){
          const chance = d.reveal * (inZone(P.x,P.y, ST.shower) ? 1.0 : 0.35);
          if(rng() < chance*0.005){ s.state='revealed'; s.wetUnlocked=true; }
        }
      }
    }

    // Holding actions (RUN & PRACTICE)
    if(holding){
      holdMs += dt;

      // (1) mini-quest: pick item by holding near any time
      const it = itemAtPlayer();
      if(it && holdMs>260){
        pickItem(it);
        setHolding(false);
      }

      const atShower = inZone(P.x,P.y,ST.shower);
      const atSoap   = inZone(P.x,P.y,ST.soap);
      const atScan   = inZone(P.x,P.y,ST.scan);
      const atTowel  = inZone(P.x,P.y,ST.towel);
      const atBasket = inZone(P.x,P.y,ST.basket);

      // Scan
      if(tool==='scan'){
        if(atScan && holdMs>220 && scanLeft>0){
          scanLeft--;
          STATS.scansUsed++;
          for(const s of spots){ if(s.state==='hidden'){ s.state='revealed'; s.wetUnlocked=true; } }
          heat = clamp(heat + (mode===MODE.PRACTICE?1:4), 0, 100);
          beep(540,0.06,'sine',0.05);
          rumble(18);
          coachSay(`UV Scan ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏´‡πá‡∏ô‡∏à‡∏∏‡∏î‡∏≠‡∏±‡∏ö (‡πÄ‡∏´‡∏•‡∏∑‡∏≠ ${scanLeft})`);
          if(mode===MODE.PRACTICE) pracGoals.scan=true;
          setHolding(false);
        } else if(!atScan && holdMs>300){
          coachSay('Scan ‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡∏ó‡∏µ‡πà UV Mirror ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏Ñ‡∏£‡∏≤‡∏ö');
          setHolding(false);
        }
      }

      // Practice goals
      if(mode===MODE.PRACTICE){
        if(tool==='water' && atShower && holdMs>260){
          pracGoals.shower=true; beep(620,0.05,'triangle',0.04);
          coachSay('Practice: Shower OK ‚Äî ‡πÑ‡∏õ Soap Rack ‡∏ï‡πà‡∏≠');
          setHolding(false);
        }
        if(tool==='soap' && atSoap && holdMs>260){
          pracGoals.soap=true; beep(680,0.05,'triangle',0.04);
          coachSay('Practice: Soap OK ‚Äî ‡πÑ‡∏õ UV Mirror ‡∏ï‡πà‡∏≠');
          setHolding(false);
        }
      }

      // RUN phases
      if(mode===MODE.RUN){
        // Phase WET
        if(phase===PH.WET){
          if(tool==='water' && atShower){
            // shower cooling
            heat = clamp(heat - dt/1000*0.55, 0, 100);
            for(const s of spots){
              if(s.state==='hidden' && rng()<0.012){ s.state='revealed'; s.wetUnlocked=true; }
              if(s.state==='revealed'){
                applySeq(s,'wet');
              }
            }
            const wetCount = spots.filter(s=>s.lastStep==='wet').length;
            if(wetCount>=3) setPhase(PH.SOAP);
          } else if(tool==='water' && !atShower && holdMs>260){
            coachSay('Wet ‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡πÉ‡∏ô Shower ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÄ‡∏õ‡∏µ‡∏¢‡∏Å‡πÑ‡∏°‡πà‡∏ó‡∏±‡πà‡∏ß ‡∏ü‡∏≠‡∏Å‡πÑ‡∏°‡πà‡∏ï‡∏¥‡∏î');
          }
        }

        // Phase SOAP
        if(phase===PH.SOAP){
          if(tool==='soap' && atSoap){
            for(const s of spots){
              if(s.state==='revealed'){
                applySeq(s,'soap');
                bubble -= dt/1000 * 10 * s.weight;
                s.prog = clamp(s.prog + dt/1000 * 0.70, 0, 1);
                if(s.prog>=1){
                  s.state='soaped'; s.prog=0;
                  beep(520,0.03,'sine',0.02);
                }
              }
            }
            if(spots.filter(s=>s.state==='soaped').length>=2) setPhase(PH.SCRUB);
          } else if(tool==='soap' && !atSoap && holdMs>260){
            coachSay('Soap ‡∏ó‡∏µ‡πà Soap Rack ‡∏Ñ‡∏∏‡πâ‡∏°‡∏™‡∏∏‡∏î ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î Bubble ‡πÅ‡∏•‡∏∞‡πÅ‡∏£‡∏á‡∏Å‡∏ß‡πà‡∏≤');
          }
        }

        // Phase SCRUB
        if(phase===PH.SCRUB){
          if(tool==='scrub'){
            for(const s of spots){
              if(s.state==='soaped'){
                applySeq(s,'scrub');
                const need = s.hold * d.holdMul * (bubble<18?1.25:1.0) * (heat>75?1.15:1.0);
                bubble -= dt/1000 * 7 * s.weight;
                s.prog = clamp(s.prog + dt/need, 0, 1);
                if(s.prog>=1){
                  s.state='cleanCandidate'; s.prog=0;
                  s.cleaned=true;
                  beep(740,0.05,'triangle',0.05); rumble(16);

                  // mission 1 progress
                  const m1 = missions.find(m=>m.id==='m1');
                  if(m1 && m1.targets.includes(s.id)){
                    if(!m1._doneSet) m1._doneSet = {};
                    if(!m1._doneSet[s.id]){
                      m1._doneSet[s.id]=true;
                      missionAddDone('m1',1);
                    }
                  }

                  // boss damage
                  if(boss && boss.spotId===s.id){
                    if(boss.type==='oil' && boss.armor>0){
                      boss.armor--;
                      damageBoss(22);
                      coachSay('‡∏•‡∏≠‡∏Å‡∏ä‡∏±‡πâ‡∏ô‡∏ô‡πâ‡∏≥‡∏°‡∏±‡∏ô ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: Wet+Soap ‡∏Å‡πà‡∏≠‡∏ô Scrub ‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡∏´‡∏•‡∏∏‡∏î');
                    } else {
                      damageBoss(30);
                    }
                  }
                }
              } else if(s.state==='revealed'){
                s.shinyNotClean = true;
              }
            }
            const anySoaped = spots.some(s=>s.state==='soaped');
            const anyCandidate = spots.some(s=>s.state==='cleanCandidate');
            if(!anySoaped && anyCandidate) setPhase(PH.RINSE);
          }
        }

        // Phase RINSE
        if(phase===PH.RINSE){
          if(tool==='rinse' && atShower){
            heat = clamp(heat - dt/1000*0.50, 0, 100);
            for(const s of spots){
              if(s.state==='cleanCandidate'){
                applySeq(s,'rinse');
                if(s.shinyNotClean || heat>82){
                  STATS.residuePenalty += 6;
                  s.mistakes++;
                  s.state='soaped';
                  s.shinyNotClean=false;
                  beep(250,0.06,'square',0.03); rumble(22);
                  coachSay(`Residue ‡∏ó‡∏µ‡πà ${s.name} ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏ñ‡∏π‡πÄ‡∏£‡πá‡∏ß‡πÑ‡∏õ/‡∏£‡πâ‡∏≠‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô`);
                } else {
                  s.state='rinsed';
                  beep(500,0.03,'sine',0.02);
                }
              }
            }
            if(allRinsed()) setPhase(PH.DRY);
          } else if(tool==='rinse' && !atShower && holdMs>260){
            coachSay('Rinse ‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥‡πÉ‡∏ô Shower ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡πÑ‡∏°‡πà‡∏•‡πâ‡∏≤‡∏á‡∏ü‡∏≠‡∏á = residue');
          }
        }

        // Phase DRY
        if(phase===PH.DRY){
          if(tool==='dry' && atTowel){
            heat = clamp(heat - dt/1000*0.15, 0, 100);
            for(const s of spots){
              if(s.state==='rinsed'){
                applySeq(s,'dry');
                s.prog = clamp(s.prog + dt/1000 * 0.70, 0, 1);
                if(s.prog>=1){ s.state='dried'; s.prog=0; beep(560,0.03,'sine',0.02); }
              }
            }
            if(spots.every(s=>s.state==='dried' || s.state==='done')) setPhase(PH.DRESS);
          } else if(tool==='dry' && !atTowel && holdMs>260){
            coachSay('Dry ‡∏ó‡∏µ‡πà Towel ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏∑‡πâ‡∏ô ‡∏•‡∏î‡πÄ‡∏ä‡∏∑‡πâ‡∏≠‡∏£‡∏≤');
          }
        }

        // Phase DRESS
        if(phase===PH.DRESS){
          if(atBasket){
            const wetLeft = spots.filter(s=>s.state!=='dried' && s.state!=='done').length;
            if(wetLeft>0){ STATS.fungusRisk += wetLeft*6; }
            if(heat>75) STATS.fungusRisk += 8;

            for(const s of spots){
              if(s.state==='dried'){
                applySeq(s,'dress');
                s.state='done';
              }
            }
            endGame(true);
          } else if(holdMs>280){
            coachSay('‡πÑ‡∏õ Basket ‡πÄ‡∏û‡∏∑‡πà‡∏≠ Dress ‚Äî ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•: ‡∏õ‡∏¥‡∏î‡∏†‡∏≤‡∏£‡∏Å‡∏¥‡∏à');
          }
        }
      } // RUN
    } // holding end

    // boss spawn
    if(mode===MODE.RUN && phase>=PH.SOAP && phase<=PH.RINSE) maybeSpawnBoss();

    // missions live update
    if(missions.length){
      const m2 = missions.find(m=>m.id==='m2');
      const m3 = missions.find(m=>m.id==='m3');
      if(m2) m2.done = (heat <= m2.threshold) ? 1 : 0;
      if(m3) m3.done = (STATS.residuePenalty <= m3.limit) ? 1 : 0;
      updateMissionUI();
    }

    // coach periodic
    coachCheck();

    // timeout
    if(mode===MODE.RUN && tLeft<=0 && phase!==PH.DONE){
      endGame(false);
    }

    // UI
    timeLbl.textContent = String(Math.ceil(mode===MODE.PRACTICE ? pracLeft : tLeft));
    heatLbl.textContent = String(Math.round(heat));
    bubLbl.textContent  = String(Math.round(bubble));
    comboLbl.textContent = 'x' + combo.toFixed(1);
    heatFill.style.width = (heat)+'%';
    bubFill.style.width  = (Math.min(100, (bubble/100)*100))+'%';
    debLbl.textContent = debuffActive() ? debuff.type : '‚Äî';
  }

  // ---------- Render ----------
  function render(){
    ctx.clearRect(0,0,W,H);

    // floor base
    ctx.fillStyle = '#06102a';
    ctx.fillRect(0,0,W,H);

    // wet floor glow
    ctx.globalAlpha = 0.20;
    radialFill(WET_FLOOR.x, WET_FLOOR.y, WET_FLOOR.r, 'rgba(120,200,255,.28)', 'rgba(120,200,255,0)');
    ctx.globalAlpha = 1;

    // tiles
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = '#ffffff';
    for(let x=0;x<=W;x+=TILE){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<=H;y+=TILE){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.globalAlpha = 1;

    // obstacles
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        if(GRID[y][x]!==1) continue;
        ctx.fillStyle = 'rgba(255,255,255,.06)';
        ctx.fillRect(x*TILE, y*TILE, TILE, TILE);
        ctx.strokeStyle = 'rgba(255,255,255,.10)';
        ctx.strokeRect(x*TILE+0.5, y*TILE+0.5, TILE-1, TILE-1);
      }
    }

    // stations
    for(const k of Object.keys(ST)) drawStation(ST[k]);

    // (1) items
    for(const it of items){
      if(it.picked) continue;
      ctx.fillStyle = 'rgba(255,255,255,.06)';
      ctx.beginPath(); ctx.arc(it.x,it.y,it.r+6,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,.16)';
      ctx.beginPath(); ctx.arc(it.x,it.y,it.r+6,0,Math.PI*2); ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,.85)';
      ctx.font = '900 18px system-ui';
      const ic = it.typeId==='shampoo' ? 'üß¥' : it.typeId==='soap' ? 'ü´ß' : 'üß∫';
      ctx.fillText(ic, it.x-10, it.y+7);

      // hint ring when near
      if(inCircle(P.x,P.y, it.x,it.y, it.r+18)){
        ctx.globalAlpha=0.45;
        ctx.strokeStyle='rgba(120,200,255,.7)';
        ctx.beginPath(); ctx.arc(it.x,it.y,it.r+18,0,Math.PI*2); ctx.stroke();
        ctx.globalAlpha=1;
      }
    }

    // player
    ctx.fillStyle = 'rgba(120,200,255,.95)';
    ctx.beginPath(); ctx.arc(P.x,P.y,P.r,0,Math.PI*2); ctx.fill();

    // aura
    ctx.strokeStyle = holding ? 'rgba(255,255,255,.28)' : 'rgba(255,255,255,.10)';
    ctx.beginPath(); ctx.arc(P.x,P.y, 42,0,Math.PI*2); ctx.stroke();

    // spots around player
    for(const s of spots){
      const x = P.x + s.ox, y = P.y + s.oy;
      if(s.state==='hidden') continue;

      if(s.state==='revealed'){ ctx.fillStyle = 'rgba(255,220,120,.30)'; spark(x,y, 10); }
      if(s.state==='soaped'){ ctx.fillStyle = 'rgba(200,240,255,.55)'; bubbleDot(x,y, 10); progArc(x,y, 14, s.prog, 'rgba(200,240,255,.85)'); }
      if(s.state==='cleanCandidate'){ ctx.fillStyle = 'rgba(160,255,160,.55)'; glow(x,y, 10); }
      if(s.state==='rinsed'){ ctx.fillStyle = 'rgba(140,210,255,.42)'; glow(x,y, 8); }
      if(s.state==='dried'){ ctx.fillStyle = 'rgba(255,255,255,.28)'; glow(x,y, 7); }
      if(s.state==='done'){ ctx.fillStyle = 'rgba(108,255,159,.22)'; glow(x,y, 6); }

      if(boss && boss.spotId===s.id){
        ctx.strokeStyle = 'rgba(255,90,120,.85)';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(x,y, 18,0,Math.PI*2); ctx.stroke();
        ctx.lineWidth = 1;
        if(boss.type==='oil' && boss.armor>0){
          ctx.fillStyle = 'rgba(255,90,120,.20)';
          ctx.font = '900 12px system-ui';
          ctx.fillText('ARMOR '+boss.armor, x-24, y-22);
        }
      }
    }

    // overlay info
    ctx.fillStyle = 'rgba(255,255,255,.06)';
    ctx.fillRect(10,10, 420, 34);
    ctx.fillStyle = '#e8ecff';
    ctx.font = '800 13px system-ui';
    const deb = debuffActive()?debuff.type:'‚Äî';
    ctx.fillText(`Tool:${tool.toUpperCase()} UV:${scanLeft} Boss:${boss?boss.type:'‚Äî'} Debuff:${deb} Items:${items.filter(i=>!i.picked).length}`, 18, 32);
  }

  function radialFill(x,y,r, c1, c2){
    const g = ctx.createRadialGradient(x,y, 0, x,y, r);
    g.addColorStop(0, c1);
    g.addColorStop(1, c2);
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }
  function drawStation(s){
    ctx.fillStyle = 'rgba(255,255,255,.05)';
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,.14)';
    ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,.78)';
    ctx.font = '800 13px system-ui';
    ctx.fillText(s.label, s.x - s.r + 10, s.y + 4);
  }
  function spark(x,y,n){
    for(let i=0;i<n;i++){
      const a = i/n*Math.PI*2;
      const rr = 6 + (i%3)*2;
      ctx.globalAlpha = 0.35;
      ctx.beginPath();
      ctx.arc(x+Math.cos(a)*rr, y+Math.sin(a)*rr, 2, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }
  function glow(x,y,r){
    ctx.globalAlpha = 0.65;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }
  function bubbleDot(x,y,r){
    ctx.globalAlpha = 0.75;
    ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;
  }
  function progArc(x,y,r,p,color){
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(x,y,r, -Math.PI/2, -Math.PI/2 + Math.PI*2*p);
    ctx.stroke();
    ctx.lineWidth = 1;
  }

  // ---------- End game ----------
  function endGame(completed){
    missionFinalize();
    const mBonus = missionBonusTotal();

    const doneCount = spots.filter(s=>s.state==='done').length;
    const cleanedCount = spots.filter(s=>s.cleaned).length;

    // (1) mini-quest bonus adds to score
    const miniBonus = STATS.miniQuestPass*8 - STATS.miniQuestFail*6;

    const base = doneCount*22 + cleanedCount*10;
    const comboBonus = Math.round((combo-1.0)*50);
    const bossBonus = STATS.bossKilled*25;

    const totalSeq = STATS.seqOk + STATS.seqBad;
    const seqRate = totalSeq>0 ? (STATS.seqOk/totalSeq) : 0.0;
    const grade = seqRate>=0.90 ? 'A' : seqRate>=0.78 ? 'B' : seqRate>=0.64 ? 'C' : 'D';

    if(!completed){
      const notDry = spots.filter(s=>s.state!=='done').length;
      STATS.fungusRisk += notDry*4;
      STATS.residuePenalty += Math.round((100-heat)/20);
    }

    const residue = Math.round(STATS.residuePenalty);
    const fungus  = Math.round(STATS.fungusRisk);
    const mistakes = STATS.wrongOrder + STATS.regrowCount + STATS.spreadCount;

    const total = Math.max(0,
      Math.round(base + comboBonus + bossBonus + mBonus + miniBonus
        - residue*1.2 - fungus*1.1 - mistakes*2 - (STATS.slips*0.5))
    );

    phase = PH.DONE;
    setMode(MODE.DONE);
    phaseLbl.textContent = 'DONE';
    resultEl.style.display='block';

    beep(completed?880:260, 0.10, completed?'triangle':'sawtooth', 0.06);
    rumble(completed?40:25);

    // KPIs
    kpiEl.innerHTML = '';
    const addK = (k,v)=> {
      const s = document.createElement('span');
      s.className='pill';
      s.innerHTML = `${k}: <b>${v}</b>`;
      kpiEl.appendChild(s);
    };
    addK('Total', total);
    addK('Clean', base);
    addK('Combo+', comboBonus);
    addK('Boss+', bossBonus);
    addK('Mission+', mBonus);
    addK('Mini+', miniBonus);
    addK('Residue-', residue);
    addK('Fungus-', fungus);
    addK('Slips', STATS.slips);

    seqGradeEl.textContent = `Grade ${grade} (Seq OK ${(seqRate*100).toFixed(0)}%)`;
    notesEl.textContent =
      `Regrow ${STATS.regrowCount}, Spread ${STATS.spreadCount}, UV ${STATS.scansUsed}, Heat ${Math.round(heat)}, MiniPass ${STATS.miniQuestPass}, MiniFail ${STATS.miniQuestFail}.`;

    resSubEl.textContent = completed ? '‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏≠‡∏≤‡∏ö‡∏Ñ‡∏£‡∏ö‡∏•‡∏≥‡∏î‡∏±‡∏ö + ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡∏≠‡∏á‡∏ñ‡∏π‡∏Å‡∏à‡∏±‡∏á‡∏´‡∏ß‡∏∞‡πÑ‡∏î‡πâ‡πÇ‡∏ö‡∏ô‡∏±‡∏™' : '‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤ ‚Äî ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏´‡πâ‡∏•‡∏∑‡πà‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô';

    drawHeatmap(grade, total);

    const byMist = [...spots].sort((a,b)=> (b.mistakes||0)-(a.mistakes||0));
    const top = byMist.slice(0,3).map(s=> `${s.name} (${s.mistakes||0})`).join(', ');
    mistakesEl.textContent = 'Top mistakes: ' + (top || '‚Äî');
  }

  function drawHeatmap(grade, total){
    silCtx.clearRect(0,0,silCv.width,silCv.height);
    silCtx.fillStyle = 'rgba(255,255,255,.03)';
    silCtx.fillRect(0,0,silCv.width,silCv.height);

    const cx = silCv.width/2, cy = silCv.height/2 + 10;
    silCtx.fillStyle = 'rgba(255,255,255,.07)';
    silCtx.beginPath(); silCtx.arc(cx, cy-150, 42, 0, Math.PI*2); silCtx.fill();
    roundRectFill(silCtx, cx-70, cy-110, 140, 210, 40);
    roundRectFill(silCtx, cx-60, cy+100, 50, 150, 26);
    roundRectFill(silCtx, cx+10, cy+100, 50, 150, 26);
    roundRectFill(silCtx, cx-120, cy-90, 45, 165, 20);
    roundRectFill(silCtx, cx+75,  cy-90, 45, 165, 20);

    const POS = {
      behindEar: { x: cx-28, y: cy-160 },
      neckBack:  { x: cx+18, y: cy-145 },
      armpit:    { x: cx-84, y: cy-70 },
      elbowFold: { x: cx+98, y: cy-20 },
      belly:     { x: cx,    y: cy-10 },
      backKnee:  { x: cx-34, y: cy+170 },
      toes:      { x: cx+34, y: cy+250 },
    };

    for(const s of spots){
      const p = POS[s.id] || {x:cx,y:cy};
      const clean = (s.state==='done');
      const warn = (!clean && (s.mistakes||0)>0);
      const risk = (!clean && (s.state==='soaped' || s.state==='revealed' || s.state==='hidden'));
      const col = clean ? 'rgba(108,255,159,.85)'
                : warn ? 'rgba(255,220,120,.85)'
                : risk ? 'rgba(255,90,120,.85)'
                : 'rgba(140,210,255,.65)';
      silCtx.fillStyle = col;
      silCtx.beginPath(); silCtx.arc(p.x,p.y, 12, 0, Math.PI*2); silCtx.fill();
      silCtx.strokeStyle = 'rgba(0,0,0,.25)';
      silCtx.stroke();
      silCtx.fillStyle = 'rgba(255,255,255,.80)';
      silCtx.font = '900 12px system-ui';
      silCtx.fillText(s.name, p.x+16, p.y+4);
    }

    silCtx.fillStyle = 'rgba(255,255,255,.70)';
    silCtx.font = '900 14px system-ui';
    silCtx.fillText(`Total ${total} | Grade ${grade} | Mini ${STATS.miniQuestPass}/${STATS.miniQuestFail}`, 14, silCv.height-14);
  }

  function roundRectFill(c, x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y, x+w,y+h, r);
    c.arcTo(x+w,y+h, x,y+h, r);
    c.arcTo(x,y+h, x,y, r);
    c.arcTo(x,y, x+w,y, r);
    c.closePath();
    c.fill();
  }

  // ---------- Buttons ----------
  [...toolsEl.querySelectorAll('button[data-tool]')].forEach(b=>{
    b.addEventListener('click', ()=> setTool(b.dataset.tool));
  });

  // ---------- Start ----------
  // Important: show overlay first; it ticks after pressing start.
  // We keep overlay visible on restart; the user presses "‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ù‡∏∂‡∏Å".
})();
</script>
</body>
</html>